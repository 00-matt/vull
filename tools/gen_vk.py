#!/usr/bin/env python3

import sys
import warnings
from argparse import ArgumentParser
from datetime import datetime
from urllib import request
from xml.etree import ElementTree


# Returns true if parent_name is a parent type of derived_name (e.g. VkDevice is a parent of VkCommandBuffer).
def is_parent_of(parent_name, derived_name):
    if parent_name == derived_name:
        return True
    derived = type_dict.get(derived_name)
    if not derived:
        return False
    parents = derived.get('parent')
    if not parents:
        return False
    return any([is_parent_of(parent_name, p) for p in parents.split(',')])


desired_extensions = {
    'VK_KHR_dynamic_rendering',
    'VK_KHR_surface',
    'VK_KHR_swapchain',
    'VK_KHR_xcb_surface',
}

args_parser = ArgumentParser(description='Parse vk.xml')
args_parser.add_argument('--download-latest', action='store_true')
args = args_parser.parse_args()
if args.download_latest:
    request.urlretrieve('https://raw.githubusercontent.com/KhronosGroup/Vulkan-Docs/main/xml/vk.xml',
                        'vk.xml')
    sys.exit(0)

with open('vk.xml', 'rb') as file:
    registry = ElementTree.parse(file)

# Build a dictionary of command names (e.g. 'vkCreateImage') to command elements, first handling the base commands,
# then any aliases.
command_dict = {}
for command in filter(lambda cmd: not cmd.get('alias'), registry.findall('commands/command')):
    command_dict[command.findtext('proto/name')] = command
for alias in filter(lambda cmd: cmd.get('alias'), registry.findall('commands/command')):
    command_dict[alias.get('name')] = command_dict[alias.get('alias')]

# Build a dictionary of type names (e.g. 'VkImage') to type elements.
type_dict = {}
for vk_type in filter(lambda ty: ty.findtext('name'), registry.findall('types/type')):
    type_dict[vk_type.findtext('name')] = vk_type

# Make sure any dependency extensions are added.
for extension_name in desired_extensions.copy():
    extension = registry.find('.//extension[@name="{}"]'.format(extension_name))
    assert extension
    if dependencies := extension.get('requires'):
        for dependency in dependencies.split(','):
            desired_extensions.add(dependency)

# Build a list of desired commands to generate prototypes for, starting with core commands and then any from extensions.
desired_commands = []
for core_command in registry.findall('feature/require/command'):
    desired_commands.append(command_dict.get(core_command.get('name')))
for extension_name in desired_extensions:
    extension = registry.find('.//extension[@name="{}"]'.format(extension_name))
    assert extension
    if extension.get('supported') == 'disabled':
        warnings.warn('Extension {} is disabled'.format(extension_name))
        continue
    for functionality in extension.findall('require'):
        if functionality.get('extension') and functionality.get('extension') not in desired_extensions:
            continue
        for command in functionality.findall('command'):
            desired_commands.append(command_dict.get(command.get('name')))

desired_commands.sort(key=lambda cmd: cmd.findtext('proto/name'))
desired_commands = list(dict.fromkeys(desired_commands))

# Generate header.
generation_time = datetime.now().strftime('%d-%m-%Y %H:%M:%S')
with open('../engine/include/vull/vulkan/ContextTable.hh', 'w') as file:
    file.write('// File generated by tools/gen_vk.py on {}\n'.format(generation_time))
    file.write('#pragma once\n\n')
    file.write('#include <xcb/xcb.h> // NOLINT\n')
    file.write('#include <vulkan/vulkan_core.h> // NOLINT\n')
    file.write('#include <vulkan/vulkan_xcb.h> // NOLINT\n\n')
    file.write('namespace vull {\n\n')
    file.write('class ContextTable {\n')
    file.write('protected:\n')
    file.write('    VkInstance m_instance; // NOLINT\n')
    file.write('    VkPhysicalDevice m_physical_device; // NOLINT\n')
    file.write('    VkDevice m_device; // NOLINT\n\n')
    file.write('    void load_loader(PFN_vkGetInstanceProcAddr get_instance_proc_addr);\n')
    file.write('    void load_instance(PFN_vkGetInstanceProcAddr get_instance_proc_addr);\n')
    file.write('    void load_device();\n\n')
    file.write('private:\n')
    for command in desired_commands:
        name = command.findtext('proto/name')
        if name == 'vkGetInstanceProcAddr':
            continue
        file.write('    PFN_' + name + ' m_' + name + ';\n')
    file.write('\npublic:\n')
    for command in desired_commands:
        name = command.findtext('proto/name')
        if name == 'vkGetInstanceProcAddr':
            continue

        # Write function prototype.
        file.write('    {} {}('.format(command.findtext('proto/type'), name))
        param_index = 0
        for param in command.findall('param'):
            param_name = param.findtext('name')
            if param_name == 'device' or param_name == 'instance' or param_name == 'physicalDevice' \
                    or param_name == 'pAllocator':
                continue
            if param_index != 0:
                file.write(', ')
            param_str = ''
            for param_part in param.itertext():
                if len(param_part.strip()) != 0:
                    param_str += param_part.strip()
                    if len(param_part.strip()) != 1:
                        param_str += ' '
            file.write(param_str.strip())
            param_index += 1
        file.write(') const; // NOLINT\n')

    file.write('};\n\n')
    file.write('} // namespace vull\n')

# Generate source file.
with open('../engine/sources/vulkan/ContextTable.cc', 'w') as file:
    file.write('// File generated by tools/gen_vk.py on {}\n'.format(generation_time))
    file.write('#include <vull/vulkan/ContextTable.hh>\n\n')
    file.write('namespace vull {\n\n')

    loader_commands = []
    instance_commands = []
    device_commands = []
    for command in desired_commands:
        name = command.findtext('proto/name')
        if name == 'vkGetInstanceProcAddr':
            continue

        vk_type = command.findtext('param[1]/type')
        if name == 'vkGetDeviceProcAddr':
            vk_type = 'VkInstance'

        if is_parent_of('VkDevice', vk_type):
            device_commands.append(name)
        elif is_parent_of('VkInstance', vk_type):
            instance_commands.append(name)
        else:
            loader_commands.append(name)

    file.write('void ContextTable::load_loader(PFN_vkGetInstanceProcAddr vkGetInstanceProcAddr) {\n')
    for command in loader_commands:
        file.write('    m_{0} = reinterpret_cast<PFN_{0}>(vkGetInstanceProcAddr(nullptr, "{0}"));\n'.format(command))
    file.write('}\n\n')

    file.write('void ContextTable::load_instance(PFN_vkGetInstanceProcAddr vkGetInstanceProcAddr) {\n')
    for command in instance_commands:
        file.write('    m_{0} = reinterpret_cast<PFN_{0}>(vkGetInstanceProcAddr(m_instance, "{0}"));\n'.format(command))
    file.write('}\n\n')

    file.write('void ContextTable::load_device() {\n')
    for command in device_commands:
        file.write('    m_{0} = reinterpret_cast<PFN_{0}>(vkGetDeviceProcAddr("{0}"));\n'.format(command))
    file.write('}\n\n')

    for command in desired_commands:
        name = command.findtext('proto/name')
        if name == 'vkGetInstanceProcAddr':
            continue

        # Write function prototype.
        file.write('{} ContextTable::{}('.format(command.findtext('proto/type'), name))
        param_index = 0
        for param in command.findall('param'):
            param_name = param.findtext('name')
            if param_name == 'device' or param_name == 'instance' or param_name == 'physicalDevice' \
                    or param_name == 'pAllocator':
                continue
            if param_index != 0:
                file.write(', ')
            param_str = ''
            for param_part in param.itertext():
                if len(param_part.strip()) != 0:
                    param_str += param_part.strip()
                    if len(param_part.strip()) != 1:
                        param_str += ' '
            file.write(param_str.strip())
            param_index += 1
        file.write(') const {\n')

        # Write function body.
        file.write('    return m_{}('.format(name))
        param_index = 0
        for param in command.findall('param'):
            param_name = param.findtext('name')
            if param_name == 'device':
                param_name = 'm_device'
            elif param_name == 'instance':
                param_name = 'm_instance'
            elif param_name == 'physicalDevice':
                param_name = 'm_physical_device'
            elif param_name == 'pAllocator':
                param_name = 'nullptr'
            if param_index != 0:
                file.write(', ')
            file.write(param_name)
            param_index += 1
        file.write(');\n')
        file.write('}\n\n')
    file.write('} // namespace vull\n')
