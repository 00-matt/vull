// File generated by tools/gen_vk.py
#pragma once

#include <stdint.h>
#include <xcb/xcb.h>

namespace vull::vk {

#if defined(_WIN32)
#define VKAPI_PTR __stdcall
#else
#define VKAPI_PTR
#endif

constexpr uint32_t VK_MAX_PHYSICAL_DEVICE_NAME_SIZE = 256;
constexpr uint32_t VK_UUID_SIZE = 16;
constexpr uint32_t VK_LUID_SIZE = 8;
constexpr uint32_t VK_MAX_EXTENSION_NAME_SIZE = 256;
constexpr uint32_t VK_MAX_DESCRIPTION_SIZE = 256;
constexpr uint32_t VK_MAX_MEMORY_TYPES = 32;
constexpr uint32_t VK_MAX_MEMORY_HEAPS = 16;
constexpr float VK_LOD_CLAMP_NONE = 1000.0f;
constexpr uint32_t VK_REMAINING_MIP_LEVELS = (~0u);
constexpr uint32_t VK_REMAINING_ARRAY_LAYERS = (~0u);
constexpr uint64_t VK_WHOLE_SIZE = (~0ull);
constexpr uint32_t VK_ATTACHMENT_UNUSED = (~0u);
constexpr uint32_t VK_TRUE = 1;
constexpr uint32_t VK_FALSE = 0;
constexpr uint32_t VK_QUEUE_FAMILY_IGNORED = (~0u);
constexpr uint32_t VK_QUEUE_FAMILY_EXTERNAL = (~1u);
constexpr uint32_t VK_QUEUE_FAMILY_FOREIGN_EXT = (~2u);
constexpr uint32_t VK_SUBPASS_EXTERNAL = (~0u);
constexpr uint32_t VK_MAX_DEVICE_GROUP_SIZE = 32;
constexpr uint32_t VK_MAX_DRIVER_NAME_SIZE = 256;
constexpr uint32_t VK_MAX_DRIVER_INFO_SIZE = 256;
constexpr uint32_t VK_SHADER_UNUSED_KHR = (~0u);
constexpr uint32_t VK_MAX_GLOBAL_PRIORITY_SIZE_EXT = 16;

// Base types.
using Bool32 = uint32_t;
using DeviceAddress = uint64_t;
using DeviceSize = uint64_t;
using Flags = uint32_t;
using SampleMask = uint32_t;

// Bitmasks.
using BufferViewCreateFlags = Flags;
using CommandPoolTrimFlags = Flags;
using CompositeAlphaFlagsKHR = Flags;
using DescriptorPoolResetFlags = Flags;
using DescriptorUpdateTemplateCreateFlags = Flags;
using DeviceCreateFlags = Flags;
using DeviceGroupPresentModeFlagsKHR = Flags;
using EventCreateFlags = Flags;
using ImageViewCreateFlags = Flags;
using InstanceCreateFlags = Flags;
using MemoryMapFlags = Flags;
using PipelineCacheCreateFlags = Flags;
using PipelineColorBlendStateCreateFlags = Flags;
using PipelineDepthStencilStateCreateFlags = Flags;
using PipelineDynamicStateCreateFlags = Flags;
using PipelineInputAssemblyStateCreateFlags = Flags;
using PipelineLayoutCreateFlags = Flags;
using PipelineMultisampleStateCreateFlags = Flags;
using PipelineRasterizationStateCreateFlags = Flags;
using PipelineShaderStageCreateFlags = Flags;
using PipelineTessellationStateCreateFlags = Flags;
using PipelineVertexInputStateCreateFlags = Flags;
using PipelineViewportStateCreateFlags = Flags;
using QueryPoolCreateFlags = Flags;
using RenderPassCreateFlags = Flags;
using RenderingFlagsKHR = Flags;
using SamplerCreateFlags = Flags;
using SemaphoreCreateFlags = Flags;
using ShaderModuleCreateFlags = Flags;
using SubpassDescriptionFlags = Flags;
using SurfaceTransformFlagsKHR = Flags;
using SwapchainCreateFlagsKHR = Flags;
using XcbSurfaceCreateFlagsKHR = Flags;

// Handles.
using Buffer = struct Buffer_T *;
using BufferView = struct BufferView_T *;
using CommandBuffer = struct CommandBuffer_T *;
using CommandPool = struct CommandPool_T *;
using DescriptorPool = struct DescriptorPool_T *;
using DescriptorSet = struct DescriptorSet_T *;
using DescriptorSetLayout = struct DescriptorSetLayout_T *;
using DescriptorUpdateTemplate = struct DescriptorUpdateTemplate_T *;
using Device = struct Device_T *;
using DeviceMemory = struct DeviceMemory_T *;
using Event = struct Event_T *;
using Fence = struct Fence_T *;
using Framebuffer = struct Framebuffer_T *;
using Image = struct Image_T *;
using ImageView = struct ImageView_T *;
using Instance = struct Instance_T *;
using PhysicalDevice = struct PhysicalDevice_T *;
using Pipeline = struct Pipeline_T *;
using PipelineCache = struct PipelineCache_T *;
using PipelineLayout = struct PipelineLayout_T *;
using QueryPool = struct QueryPool_T *;
using Queue = struct Queue_T *;
using RenderPass = struct RenderPass_T *;
using Sampler = struct Sampler_T *;
using SamplerYcbcrConversion = struct SamplerYcbcrConversion_T *;
using Semaphore = struct Semaphore_T *;
using ShaderModule = struct ShaderModule_T *;
using SurfaceKHR = struct SurfaceKHR_T *;
using SwapchainKHR = struct SwapchainKHR_T *;

// Enums.
enum class Access {
    IndirectCommandRead = 1u << 0u,
    IndexRead = 1u << 1u,
    VertexAttributeRead = 1u << 2u,
    UniformRead = 1u << 3u,
    InputAttachmentRead = 1u << 4u,
    ShaderRead = 1u << 5u,
    ShaderWrite = 1u << 6u,
    ColorAttachmentRead = 1u << 7u,
    ColorAttachmentWrite = 1u << 8u,
    DepthStencilAttachmentRead = 1u << 9u,
    DepthStencilAttachmentWrite = 1u << 10u,
    TransferRead = 1u << 11u,
    TransferWrite = 1u << 12u,
    HostRead = 1u << 13u,
    HostWrite = 1u << 14u,
    MemoryRead = 1u << 15u,
    MemoryWrite = 1u << 16u,
};
inline constexpr Access operator&(Access a, Access b) {
    return static_cast<Access>(static_cast<uint32_t>(a) & static_cast<uint32_t>(b));
}
inline constexpr Access operator|(Access a, Access b) {
    return static_cast<Access>(static_cast<uint32_t>(a) | static_cast<uint32_t>(b));
}

enum class AttachmentDescriptionFlags {
    None = 0,
    MayAlias = 1u << 0u,
};
inline constexpr AttachmentDescriptionFlags operator&(AttachmentDescriptionFlags a, AttachmentDescriptionFlags b) {
    return static_cast<AttachmentDescriptionFlags>(static_cast<uint32_t>(a) & static_cast<uint32_t>(b));
}
inline constexpr AttachmentDescriptionFlags operator|(AttachmentDescriptionFlags a, AttachmentDescriptionFlags b) {
    return static_cast<AttachmentDescriptionFlags>(static_cast<uint32_t>(a) | static_cast<uint32_t>(b));
}

enum class AttachmentLoadOp {
    Load = 0,
    Clear = 1,
    DontCare = 2,
};

enum class AttachmentStoreOp {
    Store = 0,
    DontCare = 1,
    NoneKHR = 1000301000,
};

enum class BlendFactor {
    Zero = 0,
    One = 1,
    SrcColor = 2,
    OneMinusSrcColor = 3,
    DstColor = 4,
    OneMinusDstColor = 5,
    SrcAlpha = 6,
    OneMinusSrcAlpha = 7,
    DstAlpha = 8,
    OneMinusDstAlpha = 9,
    ConstantColor = 10,
    OneMinusConstantColor = 11,
    ConstantAlpha = 12,
    OneMinusConstantAlpha = 13,
    SrcAlphaSaturate = 14,
    Src1Color = 15,
    OneMinusSrc1Color = 16,
    Src1Alpha = 17,
    OneMinusSrc1Alpha = 18,
};

enum class BlendOp {
    Add = 0,
    Subtract = 1,
    ReverseSubtract = 2,
    Min = 3,
    Max = 4,
};

enum class BorderColor {
    FloatTransparentBlack = 0,
    IntTransparentBlack = 1,
    FloatOpaqueBlack = 2,
    IntOpaqueBlack = 3,
    FloatOpaqueWhite = 4,
    IntOpaqueWhite = 5,
};

enum class BufferCreateFlags {
    None = 0,
    SparseBinding = 1u << 0u,
    SparseResidency = 1u << 1u,
    SparseAliased = 1u << 2u,
    Protected = 1u << 3u,
    DeviceAddressCaptureReplay = 1u << 4u,
};
inline constexpr BufferCreateFlags operator&(BufferCreateFlags a, BufferCreateFlags b) {
    return static_cast<BufferCreateFlags>(static_cast<uint32_t>(a) & static_cast<uint32_t>(b));
}
inline constexpr BufferCreateFlags operator|(BufferCreateFlags a, BufferCreateFlags b) {
    return static_cast<BufferCreateFlags>(static_cast<uint32_t>(a) | static_cast<uint32_t>(b));
}

enum class BufferUsage {
    TransferSrc = 1u << 0u,
    TransferDst = 1u << 1u,
    UniformTexelBuffer = 1u << 2u,
    StorageTexelBuffer = 1u << 3u,
    UniformBuffer = 1u << 4u,
    StorageBuffer = 1u << 5u,
    IndexBuffer = 1u << 6u,
    VertexBuffer = 1u << 7u,
    IndirectBuffer = 1u << 8u,
    ShaderDeviceAddress = 1u << 17u,
};
inline constexpr BufferUsage operator&(BufferUsage a, BufferUsage b) {
    return static_cast<BufferUsage>(static_cast<uint32_t>(a) & static_cast<uint32_t>(b));
}
inline constexpr BufferUsage operator|(BufferUsage a, BufferUsage b) {
    return static_cast<BufferUsage>(static_cast<uint32_t>(a) | static_cast<uint32_t>(b));
}

enum class ChromaLocation {
    CositedEven = 0,
    Midpoint = 1,
};

enum class ColorComponent {
    R = 1u << 0u,
    G = 1u << 1u,
    B = 1u << 2u,
    A = 1u << 3u,
};
inline constexpr ColorComponent operator&(ColorComponent a, ColorComponent b) {
    return static_cast<ColorComponent>(static_cast<uint32_t>(a) & static_cast<uint32_t>(b));
}
inline constexpr ColorComponent operator|(ColorComponent a, ColorComponent b) {
    return static_cast<ColorComponent>(static_cast<uint32_t>(a) | static_cast<uint32_t>(b));
}

enum class ColorSpaceKHR {
    SrgbNonlinearKHR = 0,
};

enum class CommandBufferLevel {
    Primary = 0,
    Secondary = 1,
};

enum class CommandBufferResetFlags {
    None = 0,
    ReleaseResources = 1u << 0u,
};
inline constexpr CommandBufferResetFlags operator&(CommandBufferResetFlags a, CommandBufferResetFlags b) {
    return static_cast<CommandBufferResetFlags>(static_cast<uint32_t>(a) & static_cast<uint32_t>(b));
}
inline constexpr CommandBufferResetFlags operator|(CommandBufferResetFlags a, CommandBufferResetFlags b) {
    return static_cast<CommandBufferResetFlags>(static_cast<uint32_t>(a) | static_cast<uint32_t>(b));
}

enum class CommandBufferUsage {
    OneTimeSubmit = 1u << 0u,
    RenderPassContinue = 1u << 1u,
    SimultaneousUse = 1u << 2u,
};
inline constexpr CommandBufferUsage operator&(CommandBufferUsage a, CommandBufferUsage b) {
    return static_cast<CommandBufferUsage>(static_cast<uint32_t>(a) & static_cast<uint32_t>(b));
}
inline constexpr CommandBufferUsage operator|(CommandBufferUsage a, CommandBufferUsage b) {
    return static_cast<CommandBufferUsage>(static_cast<uint32_t>(a) | static_cast<uint32_t>(b));
}

enum class CommandPoolCreateFlags {
    None = 0,
    Transient = 1u << 0u,
    ResetCommandBuffer = 1u << 1u,
    Protected = 1u << 2u,
};
inline constexpr CommandPoolCreateFlags operator&(CommandPoolCreateFlags a, CommandPoolCreateFlags b) {
    return static_cast<CommandPoolCreateFlags>(static_cast<uint32_t>(a) & static_cast<uint32_t>(b));
}
inline constexpr CommandPoolCreateFlags operator|(CommandPoolCreateFlags a, CommandPoolCreateFlags b) {
    return static_cast<CommandPoolCreateFlags>(static_cast<uint32_t>(a) | static_cast<uint32_t>(b));
}

enum class CommandPoolResetFlags {
    None = 0,
    ReleaseResources = 1u << 0u,
};
inline constexpr CommandPoolResetFlags operator&(CommandPoolResetFlags a, CommandPoolResetFlags b) {
    return static_cast<CommandPoolResetFlags>(static_cast<uint32_t>(a) & static_cast<uint32_t>(b));
}
inline constexpr CommandPoolResetFlags operator|(CommandPoolResetFlags a, CommandPoolResetFlags b) {
    return static_cast<CommandPoolResetFlags>(static_cast<uint32_t>(a) | static_cast<uint32_t>(b));
}

enum class CompareOp {
    Never = 0,
    Less = 1,
    Equal = 2,
    LessOrEqual = 3,
    Greater = 4,
    NotEqual = 5,
    GreaterOrEqual = 6,
    Always = 7,
};

enum class ComponentSwizzle {
    Identity = 0,
    Zero = 1,
    One = 2,
    R = 3,
    G = 4,
    B = 5,
    A = 6,
};

enum class CompositeAlphaFlagBitsKHR {
    OpaqueKHR = 1u << 0u,
    PreMultipliedKHR = 1u << 1u,
    PostMultipliedKHR = 1u << 2u,
    InheritKHR = 1u << 3u,
};
inline constexpr CompositeAlphaFlagBitsKHR operator&(CompositeAlphaFlagBitsKHR a, CompositeAlphaFlagBitsKHR b) {
    return static_cast<CompositeAlphaFlagBitsKHR>(static_cast<uint32_t>(a) & static_cast<uint32_t>(b));
}
inline constexpr CompositeAlphaFlagBitsKHR operator|(CompositeAlphaFlagBitsKHR a, CompositeAlphaFlagBitsKHR b) {
    return static_cast<CompositeAlphaFlagBitsKHR>(static_cast<uint32_t>(a) | static_cast<uint32_t>(b));
}

enum class CullMode {
    None = 0,
    Front = 1u << 0u,
    Back = 1u << 1u,
    FrontAndBack = 0x00000003,
};
inline constexpr CullMode operator&(CullMode a, CullMode b) {
    return static_cast<CullMode>(static_cast<uint32_t>(a) & static_cast<uint32_t>(b));
}
inline constexpr CullMode operator|(CullMode a, CullMode b) {
    return static_cast<CullMode>(static_cast<uint32_t>(a) | static_cast<uint32_t>(b));
}

enum class DependencyFlags {
    None = 0,
    ByRegion = 1u << 0u,
    DeviceGroup = 1u << 2u,
    ViewLocal = 1u << 1u,
};
inline constexpr DependencyFlags operator&(DependencyFlags a, DependencyFlags b) {
    return static_cast<DependencyFlags>(static_cast<uint32_t>(a) & static_cast<uint32_t>(b));
}
inline constexpr DependencyFlags operator|(DependencyFlags a, DependencyFlags b) {
    return static_cast<DependencyFlags>(static_cast<uint32_t>(a) | static_cast<uint32_t>(b));
}

enum class DescriptorBindingFlags {
    None = 0,
    UpdateAfterBind = 1u << 0u,
    UpdateUnusedWhilePending = 1u << 1u,
    PartiallyBound = 1u << 2u,
    VariableDescriptorCount = 1u << 3u,
};
inline constexpr DescriptorBindingFlags operator&(DescriptorBindingFlags a, DescriptorBindingFlags b) {
    return static_cast<DescriptorBindingFlags>(static_cast<uint32_t>(a) & static_cast<uint32_t>(b));
}
inline constexpr DescriptorBindingFlags operator|(DescriptorBindingFlags a, DescriptorBindingFlags b) {
    return static_cast<DescriptorBindingFlags>(static_cast<uint32_t>(a) | static_cast<uint32_t>(b));
}

enum class DescriptorPoolCreateFlags {
    None = 0,
    FreeDescriptorSet = 1u << 0u,
    UpdateAfterBind = 1u << 1u,
};
inline constexpr DescriptorPoolCreateFlags operator&(DescriptorPoolCreateFlags a, DescriptorPoolCreateFlags b) {
    return static_cast<DescriptorPoolCreateFlags>(static_cast<uint32_t>(a) & static_cast<uint32_t>(b));
}
inline constexpr DescriptorPoolCreateFlags operator|(DescriptorPoolCreateFlags a, DescriptorPoolCreateFlags b) {
    return static_cast<DescriptorPoolCreateFlags>(static_cast<uint32_t>(a) | static_cast<uint32_t>(b));
}

enum class DescriptorSetLayoutCreateFlags {
    None = 0,
    UpdateAfterBindPool = 1u << 1u,
};
inline constexpr DescriptorSetLayoutCreateFlags operator&(DescriptorSetLayoutCreateFlags a, DescriptorSetLayoutCreateFlags b) {
    return static_cast<DescriptorSetLayoutCreateFlags>(static_cast<uint32_t>(a) & static_cast<uint32_t>(b));
}
inline constexpr DescriptorSetLayoutCreateFlags operator|(DescriptorSetLayoutCreateFlags a, DescriptorSetLayoutCreateFlags b) {
    return static_cast<DescriptorSetLayoutCreateFlags>(static_cast<uint32_t>(a) | static_cast<uint32_t>(b));
}

enum class DescriptorType {
    Sampler = 0,
    CombinedImageSampler = 1,
    SampledImage = 2,
    StorageImage = 3,
    UniformTexelBuffer = 4,
    StorageTexelBuffer = 5,
    UniformBuffer = 6,
    StorageBuffer = 7,
    UniformBufferDynamic = 8,
    StorageBufferDynamic = 9,
    InputAttachment = 10,
};

enum class DescriptorUpdateTemplateType {
    DescriptorSet = 0,
};

enum class DeviceGroupPresentModeFlagBitsKHR {
    LocalKHR = 1u << 0u,
    RemoteKHR = 1u << 1u,
    SumKHR = 1u << 2u,
    LocalMultiDeviceKHR = 1u << 3u,
};
inline constexpr DeviceGroupPresentModeFlagBitsKHR operator&(DeviceGroupPresentModeFlagBitsKHR a, DeviceGroupPresentModeFlagBitsKHR b) {
    return static_cast<DeviceGroupPresentModeFlagBitsKHR>(static_cast<uint32_t>(a) & static_cast<uint32_t>(b));
}
inline constexpr DeviceGroupPresentModeFlagBitsKHR operator|(DeviceGroupPresentModeFlagBitsKHR a, DeviceGroupPresentModeFlagBitsKHR b) {
    return static_cast<DeviceGroupPresentModeFlagBitsKHR>(static_cast<uint32_t>(a) | static_cast<uint32_t>(b));
}

enum class DeviceQueueCreateFlags {
    None = 0,
    Protected = 1u << 0u,
};
inline constexpr DeviceQueueCreateFlags operator&(DeviceQueueCreateFlags a, DeviceQueueCreateFlags b) {
    return static_cast<DeviceQueueCreateFlags>(static_cast<uint32_t>(a) & static_cast<uint32_t>(b));
}
inline constexpr DeviceQueueCreateFlags operator|(DeviceQueueCreateFlags a, DeviceQueueCreateFlags b) {
    return static_cast<DeviceQueueCreateFlags>(static_cast<uint32_t>(a) | static_cast<uint32_t>(b));
}

enum class DriverId {
    AmdProprietary = 1,
    AmdOpenSource = 2,
    MesaRadv = 3,
    NvidiaProprietary = 4,
    IntelProprietaryWindows = 5,
    IntelOpenSourceMESA = 6,
    ImaginationProprietary = 7,
    QualcommProprietary = 8,
    ArmProprietary = 9,
    GoogleSwiftshader = 10,
    GgpProprietary = 11,
    BroadcomProprietary = 12,
    MesaLlvmpipe = 13,
    Moltenvk = 14,
    CoreaviProprietary = 15,
    JuiceProprietary = 16,
    VerisiliconProprietary = 17,
    MesaTurnip = 18,
    MesaV3Dv = 19,
    MesaPanvk = 20,
    SamsungProprietary = 21,
    MesaVenus = 22,
};

enum class DynamicState {
    Viewport = 0,
    Scissor = 1,
    LineWidth = 2,
    DepthBias = 3,
    BlendConstants = 4,
    DepthBounds = 5,
    StencilCompareMask = 6,
    StencilWriteMask = 7,
    StencilReference = 8,
};

enum class ExternalFenceFeature {
    Exportable = 1u << 0u,
    Importable = 1u << 1u,
};
inline constexpr ExternalFenceFeature operator&(ExternalFenceFeature a, ExternalFenceFeature b) {
    return static_cast<ExternalFenceFeature>(static_cast<uint32_t>(a) & static_cast<uint32_t>(b));
}
inline constexpr ExternalFenceFeature operator|(ExternalFenceFeature a, ExternalFenceFeature b) {
    return static_cast<ExternalFenceFeature>(static_cast<uint32_t>(a) | static_cast<uint32_t>(b));
}

enum class ExternalFenceHandleTypeFlags {
    None = 0,
    OpaqueFd = 1u << 0u,
    OpaqueWin32 = 1u << 1u,
    OpaqueWin32Kmt = 1u << 2u,
    SyncFd = 1u << 3u,
};
inline constexpr ExternalFenceHandleTypeFlags operator&(ExternalFenceHandleTypeFlags a, ExternalFenceHandleTypeFlags b) {
    return static_cast<ExternalFenceHandleTypeFlags>(static_cast<uint32_t>(a) & static_cast<uint32_t>(b));
}
inline constexpr ExternalFenceHandleTypeFlags operator|(ExternalFenceHandleTypeFlags a, ExternalFenceHandleTypeFlags b) {
    return static_cast<ExternalFenceHandleTypeFlags>(static_cast<uint32_t>(a) | static_cast<uint32_t>(b));
}

enum class ExternalMemoryFeature {
    DedicatedOnly = 1u << 0u,
    Exportable = 1u << 1u,
    Importable = 1u << 2u,
};
inline constexpr ExternalMemoryFeature operator&(ExternalMemoryFeature a, ExternalMemoryFeature b) {
    return static_cast<ExternalMemoryFeature>(static_cast<uint32_t>(a) & static_cast<uint32_t>(b));
}
inline constexpr ExternalMemoryFeature operator|(ExternalMemoryFeature a, ExternalMemoryFeature b) {
    return static_cast<ExternalMemoryFeature>(static_cast<uint32_t>(a) | static_cast<uint32_t>(b));
}

enum class ExternalMemoryHandleTypeFlags {
    None = 0,
    OpaqueFd = 1u << 0u,
    OpaqueWin32 = 1u << 1u,
    OpaqueWin32Kmt = 1u << 2u,
    D3D11Texture = 1u << 3u,
    D3D11TextureKmt = 1u << 4u,
    D3D12Heap = 1u << 5u,
    D3D12Resource = 1u << 6u,
};
inline constexpr ExternalMemoryHandleTypeFlags operator&(ExternalMemoryHandleTypeFlags a, ExternalMemoryHandleTypeFlags b) {
    return static_cast<ExternalMemoryHandleTypeFlags>(static_cast<uint32_t>(a) & static_cast<uint32_t>(b));
}
inline constexpr ExternalMemoryHandleTypeFlags operator|(ExternalMemoryHandleTypeFlags a, ExternalMemoryHandleTypeFlags b) {
    return static_cast<ExternalMemoryHandleTypeFlags>(static_cast<uint32_t>(a) | static_cast<uint32_t>(b));
}

enum class ExternalSemaphoreFeature {
    Exportable = 1u << 0u,
    Importable = 1u << 1u,
};
inline constexpr ExternalSemaphoreFeature operator&(ExternalSemaphoreFeature a, ExternalSemaphoreFeature b) {
    return static_cast<ExternalSemaphoreFeature>(static_cast<uint32_t>(a) & static_cast<uint32_t>(b));
}
inline constexpr ExternalSemaphoreFeature operator|(ExternalSemaphoreFeature a, ExternalSemaphoreFeature b) {
    return static_cast<ExternalSemaphoreFeature>(static_cast<uint32_t>(a) | static_cast<uint32_t>(b));
}

enum class ExternalSemaphoreHandleTypeFlags {
    None = 0,
    OpaqueFd = 1u << 0u,
    OpaqueWin32 = 1u << 1u,
    OpaqueWin32Kmt = 1u << 2u,
    D3D12Fence = 1u << 3u,
    SyncFd = 1u << 4u,
};
inline constexpr ExternalSemaphoreHandleTypeFlags operator&(ExternalSemaphoreHandleTypeFlags a, ExternalSemaphoreHandleTypeFlags b) {
    return static_cast<ExternalSemaphoreHandleTypeFlags>(static_cast<uint32_t>(a) & static_cast<uint32_t>(b));
}
inline constexpr ExternalSemaphoreHandleTypeFlags operator|(ExternalSemaphoreHandleTypeFlags a, ExternalSemaphoreHandleTypeFlags b) {
    return static_cast<ExternalSemaphoreHandleTypeFlags>(static_cast<uint32_t>(a) | static_cast<uint32_t>(b));
}

enum class FenceCreateFlags {
    None = 0,
    Signaled = 1u << 0u,
};
inline constexpr FenceCreateFlags operator&(FenceCreateFlags a, FenceCreateFlags b) {
    return static_cast<FenceCreateFlags>(static_cast<uint32_t>(a) & static_cast<uint32_t>(b));
}
inline constexpr FenceCreateFlags operator|(FenceCreateFlags a, FenceCreateFlags b) {
    return static_cast<FenceCreateFlags>(static_cast<uint32_t>(a) | static_cast<uint32_t>(b));
}

enum class FenceImportFlags {
    None = 0,
    Temporary = 1u << 0u,
};
inline constexpr FenceImportFlags operator&(FenceImportFlags a, FenceImportFlags b) {
    return static_cast<FenceImportFlags>(static_cast<uint32_t>(a) & static_cast<uint32_t>(b));
}
inline constexpr FenceImportFlags operator|(FenceImportFlags a, FenceImportFlags b) {
    return static_cast<FenceImportFlags>(static_cast<uint32_t>(a) | static_cast<uint32_t>(b));
}

enum class Filter {
    Nearest = 0,
    Linear = 1,
};

enum class Format {
    Undefined = 0,
    R4G4UnormPack8 = 1,
    R4G4B4A4UnormPack16 = 2,
    B4G4R4A4UnormPack16 = 3,
    R5G6B5UnormPack16 = 4,
    B5G6R5UnormPack16 = 5,
    R5G5B5A1UnormPack16 = 6,
    B5G5R5A1UnormPack16 = 7,
    A1R5G5B5UnormPack16 = 8,
    R8Unorm = 9,
    R8Snorm = 10,
    R8Uscaled = 11,
    R8Sscaled = 12,
    R8Uint = 13,
    R8Sint = 14,
    R8Srgb = 15,
    R8G8Unorm = 16,
    R8G8Snorm = 17,
    R8G8Uscaled = 18,
    R8G8Sscaled = 19,
    R8G8Uint = 20,
    R8G8Sint = 21,
    R8G8Srgb = 22,
    R8G8B8Unorm = 23,
    R8G8B8Snorm = 24,
    R8G8B8Uscaled = 25,
    R8G8B8Sscaled = 26,
    R8G8B8Uint = 27,
    R8G8B8Sint = 28,
    R8G8B8Srgb = 29,
    B8G8R8Unorm = 30,
    B8G8R8Snorm = 31,
    B8G8R8Uscaled = 32,
    B8G8R8Sscaled = 33,
    B8G8R8Uint = 34,
    B8G8R8Sint = 35,
    B8G8R8Srgb = 36,
    R8G8B8A8Unorm = 37,
    R8G8B8A8Snorm = 38,
    R8G8B8A8Uscaled = 39,
    R8G8B8A8Sscaled = 40,
    R8G8B8A8Uint = 41,
    R8G8B8A8Sint = 42,
    R8G8B8A8Srgb = 43,
    B8G8R8A8Unorm = 44,
    B8G8R8A8Snorm = 45,
    B8G8R8A8Uscaled = 46,
    B8G8R8A8Sscaled = 47,
    B8G8R8A8Uint = 48,
    B8G8R8A8Sint = 49,
    B8G8R8A8Srgb = 50,
    A8B8G8R8UnormPack32 = 51,
    A8B8G8R8SnormPack32 = 52,
    A8B8G8R8UscaledPack32 = 53,
    A8B8G8R8SscaledPack32 = 54,
    A8B8G8R8UintPack32 = 55,
    A8B8G8R8SintPack32 = 56,
    A8B8G8R8SrgbPack32 = 57,
    A2R10G10B10UnormPack32 = 58,
    A2R10G10B10SnormPack32 = 59,
    A2R10G10B10UscaledPack32 = 60,
    A2R10G10B10SscaledPack32 = 61,
    A2R10G10B10UintPack32 = 62,
    A2R10G10B10SintPack32 = 63,
    A2B10G10R10UnormPack32 = 64,
    A2B10G10R10SnormPack32 = 65,
    A2B10G10R10UscaledPack32 = 66,
    A2B10G10R10SscaledPack32 = 67,
    A2B10G10R10UintPack32 = 68,
    A2B10G10R10SintPack32 = 69,
    R16Unorm = 70,
    R16Snorm = 71,
    R16Uscaled = 72,
    R16Sscaled = 73,
    R16Uint = 74,
    R16Sint = 75,
    R16Sfloat = 76,
    R16G16Unorm = 77,
    R16G16Snorm = 78,
    R16G16Uscaled = 79,
    R16G16Sscaled = 80,
    R16G16Uint = 81,
    R16G16Sint = 82,
    R16G16Sfloat = 83,
    R16G16B16Unorm = 84,
    R16G16B16Snorm = 85,
    R16G16B16Uscaled = 86,
    R16G16B16Sscaled = 87,
    R16G16B16Uint = 88,
    R16G16B16Sint = 89,
    R16G16B16Sfloat = 90,
    R16G16B16A16Unorm = 91,
    R16G16B16A16Snorm = 92,
    R16G16B16A16Uscaled = 93,
    R16G16B16A16Sscaled = 94,
    R16G16B16A16Uint = 95,
    R16G16B16A16Sint = 96,
    R16G16B16A16Sfloat = 97,
    R32Uint = 98,
    R32Sint = 99,
    R32Sfloat = 100,
    R32G32Uint = 101,
    R32G32Sint = 102,
    R32G32Sfloat = 103,
    R32G32B32Uint = 104,
    R32G32B32Sint = 105,
    R32G32B32Sfloat = 106,
    R32G32B32A32Uint = 107,
    R32G32B32A32Sint = 108,
    R32G32B32A32Sfloat = 109,
    R64Uint = 110,
    R64Sint = 111,
    R64Sfloat = 112,
    R64G64Uint = 113,
    R64G64Sint = 114,
    R64G64Sfloat = 115,
    R64G64B64Uint = 116,
    R64G64B64Sint = 117,
    R64G64B64Sfloat = 118,
    R64G64B64A64Uint = 119,
    R64G64B64A64Sint = 120,
    R64G64B64A64Sfloat = 121,
    B10G11R11UfloatPack32 = 122,
    E5B9G9R9UfloatPack32 = 123,
    D16Unorm = 124,
    X8D24UnormPack32 = 125,
    D32Sfloat = 126,
    S8Uint = 127,
    D16UnormS8Uint = 128,
    D24UnormS8Uint = 129,
    D32SfloatS8Uint = 130,
    Bc1RgbUnormBlock = 131,
    Bc1RgbSrgbBlock = 132,
    Bc1RgbaUnormBlock = 133,
    Bc1RgbaSrgbBlock = 134,
    Bc2UnormBlock = 135,
    Bc2SrgbBlock = 136,
    Bc3UnormBlock = 137,
    Bc3SrgbBlock = 138,
    Bc4UnormBlock = 139,
    Bc4SnormBlock = 140,
    Bc5UnormBlock = 141,
    Bc5SnormBlock = 142,
    Bc6HUfloatBlock = 143,
    Bc6HSfloatBlock = 144,
    Bc7UnormBlock = 145,
    Bc7SrgbBlock = 146,
    Etc2R8G8B8UnormBlock = 147,
    Etc2R8G8B8SrgbBlock = 148,
    Etc2R8G8B8A1UnormBlock = 149,
    Etc2R8G8B8A1SrgbBlock = 150,
    Etc2R8G8B8A8UnormBlock = 151,
    Etc2R8G8B8A8SrgbBlock = 152,
    EacR11UnormBlock = 153,
    EacR11SnormBlock = 154,
    EacR11G11UnormBlock = 155,
    EacR11G11SnormBlock = 156,
    Astc4X4UnormBlock = 157,
    Astc4X4SrgbBlock = 158,
    Astc5X4UnormBlock = 159,
    Astc5X4SrgbBlock = 160,
    Astc5X5UnormBlock = 161,
    Astc5X5SrgbBlock = 162,
    Astc6X5UnormBlock = 163,
    Astc6X5SrgbBlock = 164,
    Astc6X6UnormBlock = 165,
    Astc6X6SrgbBlock = 166,
    Astc8X5UnormBlock = 167,
    Astc8X5SrgbBlock = 168,
    Astc8X6UnormBlock = 169,
    Astc8X6SrgbBlock = 170,
    Astc8X8UnormBlock = 171,
    Astc8X8SrgbBlock = 172,
    Astc10X5UnormBlock = 173,
    Astc10X5SrgbBlock = 174,
    Astc10X6UnormBlock = 175,
    Astc10X6SrgbBlock = 176,
    Astc10X8UnormBlock = 177,
    Astc10X8SrgbBlock = 178,
    Astc10X10UnormBlock = 179,
    Astc10X10SrgbBlock = 180,
    Astc12X10UnormBlock = 181,
    Astc12X10SrgbBlock = 182,
    Astc12X12UnormBlock = 183,
    Astc12X12SrgbBlock = 184,
    G8B8G8R8422Unorm = 1000156000,
    B8G8R8G8422Unorm = 1000156001,
    G8B8R83Plane420Unorm = 1000156002,
    G8B8R82Plane420Unorm = 1000156003,
    G8B8R83Plane422Unorm = 1000156004,
    G8B8R82Plane422Unorm = 1000156005,
    G8B8R83Plane444Unorm = 1000156006,
    R10X6UnormPack16 = 1000156007,
    R10X6G10X6Unorm2Pack16 = 1000156008,
    R10X6G10X6B10X6A10X6Unorm4Pack16 = 1000156009,
    G10X6B10X6G10X6R10X6422Unorm4Pack16 = 1000156010,
    B10X6G10X6R10X6G10X6422Unorm4Pack16 = 1000156011,
    G10X6B10X6R10X63Plane420Unorm3Pack16 = 1000156012,
    G10X6B10X6R10X62Plane420Unorm3Pack16 = 1000156013,
    G10X6B10X6R10X63Plane422Unorm3Pack16 = 1000156014,
    G10X6B10X6R10X62Plane422Unorm3Pack16 = 1000156015,
    G10X6B10X6R10X63Plane444Unorm3Pack16 = 1000156016,
    R12X4UnormPack16 = 1000156017,
    R12X4G12X4Unorm2Pack16 = 1000156018,
    R12X4G12X4B12X4A12X4Unorm4Pack16 = 1000156019,
    G12X4B12X4G12X4R12X4422Unorm4Pack16 = 1000156020,
    B12X4G12X4R12X4G12X4422Unorm4Pack16 = 1000156021,
    G12X4B12X4R12X43Plane420Unorm3Pack16 = 1000156022,
    G12X4B12X4R12X42Plane420Unorm3Pack16 = 1000156023,
    G12X4B12X4R12X43Plane422Unorm3Pack16 = 1000156024,
    G12X4B12X4R12X42Plane422Unorm3Pack16 = 1000156025,
    G12X4B12X4R12X43Plane444Unorm3Pack16 = 1000156026,
    G16B16G16R16422Unorm = 1000156027,
    B16G16R16G16422Unorm = 1000156028,
    G16B16R163Plane420Unorm = 1000156029,
    G16B16R162Plane420Unorm = 1000156030,
    G16B16R163Plane422Unorm = 1000156031,
    G16B16R162Plane422Unorm = 1000156032,
    G16B16R163Plane444Unorm = 1000156033,
};

enum class FormatFeature {
    SampledImage = 1u << 0u,
    StorageImage = 1u << 1u,
    StorageImageAtomic = 1u << 2u,
    UniformTexelBuffer = 1u << 3u,
    StorageTexelBuffer = 1u << 4u,
    StorageTexelBufferAtomic = 1u << 5u,
    VertexBuffer = 1u << 6u,
    ColorAttachment = 1u << 7u,
    ColorAttachmentBlend = 1u << 8u,
    DepthStencilAttachment = 1u << 9u,
    BlitSrc = 1u << 10u,
    BlitDst = 1u << 11u,
    SampledImageFilterLinear = 1u << 12u,
    TransferSrc = 1u << 14u,
    TransferDst = 1u << 15u,
    MidpointChromaSamples = 1u << 17u,
    SampledImageYcbcrConversionLinearFilter = 1u << 18u,
    SampledImageYcbcrConversionSeparateReconstructionFilter = 1u << 19u,
    SampledImageYcbcrConversionChromaReconstructionExplicit = 1u << 20u,
    SampledImageYcbcrConversionChromaReconstructionExplicitForceable = 1u << 21u,
    Disjoint = 1u << 22u,
    CositedChromaSamples = 1u << 23u,
    SampledImageFilterMinmax = 1u << 16u,
};
inline constexpr FormatFeature operator&(FormatFeature a, FormatFeature b) {
    return static_cast<FormatFeature>(static_cast<uint32_t>(a) & static_cast<uint32_t>(b));
}
inline constexpr FormatFeature operator|(FormatFeature a, FormatFeature b) {
    return static_cast<FormatFeature>(static_cast<uint32_t>(a) | static_cast<uint32_t>(b));
}

enum class FramebufferCreateFlags {
    None = 0,
    Imageless = 1u << 0u,
};
inline constexpr FramebufferCreateFlags operator&(FramebufferCreateFlags a, FramebufferCreateFlags b) {
    return static_cast<FramebufferCreateFlags>(static_cast<uint32_t>(a) & static_cast<uint32_t>(b));
}
inline constexpr FramebufferCreateFlags operator|(FramebufferCreateFlags a, FramebufferCreateFlags b) {
    return static_cast<FramebufferCreateFlags>(static_cast<uint32_t>(a) | static_cast<uint32_t>(b));
}

enum class FrontFace {
    CounterClockwise = 0,
    Clockwise = 1,
};

enum class ImageAspect {
    Color = 1u << 0u,
    Depth = 1u << 1u,
    Stencil = 1u << 2u,
    Metadata = 1u << 3u,
    Plane0 = 1u << 4u,
    Plane1 = 1u << 5u,
    Plane2 = 1u << 6u,
};
inline constexpr ImageAspect operator&(ImageAspect a, ImageAspect b) {
    return static_cast<ImageAspect>(static_cast<uint32_t>(a) & static_cast<uint32_t>(b));
}
inline constexpr ImageAspect operator|(ImageAspect a, ImageAspect b) {
    return static_cast<ImageAspect>(static_cast<uint32_t>(a) | static_cast<uint32_t>(b));
}

enum class ImageCreateFlags {
    None = 0,
    SparseBinding = 1u << 0u,
    SparseResidency = 1u << 1u,
    SparseAliased = 1u << 2u,
    MutableFormat = 1u << 3u,
    CubeCompatible = 1u << 4u,
    Alias = 1u << 10u,
    SplitInstanceBindRegions = 1u << 6u,
    _2DArrayCompatible = 1u << 5u,
    BlockTexelViewCompatible = 1u << 7u,
    ExtendedUsage = 1u << 8u,
    Protected = 1u << 11u,
    Disjoint = 1u << 9u,
};
inline constexpr ImageCreateFlags operator&(ImageCreateFlags a, ImageCreateFlags b) {
    return static_cast<ImageCreateFlags>(static_cast<uint32_t>(a) & static_cast<uint32_t>(b));
}
inline constexpr ImageCreateFlags operator|(ImageCreateFlags a, ImageCreateFlags b) {
    return static_cast<ImageCreateFlags>(static_cast<uint32_t>(a) | static_cast<uint32_t>(b));
}

enum class ImageLayout {
    Undefined = 0,
    General = 1,
    ColorAttachmentOptimal = 2,
    DepthStencilAttachmentOptimal = 3,
    DepthStencilReadOnlyOptimal = 4,
    ShaderReadOnlyOptimal = 5,
    TransferSrcOptimal = 6,
    TransferDstOptimal = 7,
    Preinitialized = 8,
    DepthReadOnlyStencilAttachmentOptimal = 1000117000,
    DepthAttachmentStencilReadOnlyOptimal = 1000117001,
    DepthAttachmentOptimal = 1000241000,
    DepthReadOnlyOptimal = 1000241001,
    StencilAttachmentOptimal = 1000241002,
    StencilReadOnlyOptimal = 1000241003,
    PresentSrcKHR = 1000001002,
};

enum class ImageTiling {
    Optimal = 0,
    Linear = 1,
};

enum class ImageType {
    _1D = 0,
    _2D = 1,
    _3D = 2,
};

enum class ImageUsage {
    TransferSrc = 1u << 0u,
    TransferDst = 1u << 1u,
    Sampled = 1u << 2u,
    Storage = 1u << 3u,
    ColorAttachment = 1u << 4u,
    DepthStencilAttachment = 1u << 5u,
    TransientAttachment = 1u << 6u,
    InputAttachment = 1u << 7u,
};
inline constexpr ImageUsage operator&(ImageUsage a, ImageUsage b) {
    return static_cast<ImageUsage>(static_cast<uint32_t>(a) & static_cast<uint32_t>(b));
}
inline constexpr ImageUsage operator|(ImageUsage a, ImageUsage b) {
    return static_cast<ImageUsage>(static_cast<uint32_t>(a) | static_cast<uint32_t>(b));
}

enum class ImageViewType {
    _1D = 0,
    _2D = 1,
    _3D = 2,
    Cube = 3,
    _1DArray = 4,
    _2DArray = 5,
    CubeArray = 6,
};

enum class IndexType {
    Uint16 = 0,
    Uint32 = 1,
};

enum class InternalAllocationType {
    Executable = 0,
};

enum class LogicOp {
    Clear = 0,
    And = 1,
    AndReverse = 2,
    Copy = 3,
    AndInverted = 4,
    NoOp = 5,
    Xor = 6,
    Or = 7,
    Nor = 8,
    Equivalent = 9,
    Invert = 10,
    OrReverse = 11,
    CopyInverted = 12,
    OrInverted = 13,
    Nand = 14,
    Set = 15,
};

enum class MemoryAllocateFlags {
    None = 0,
    DeviceMask = 1u << 0u,
    DeviceAddress = 1u << 1u,
    DeviceAddressCaptureReplay = 1u << 2u,
};
inline constexpr MemoryAllocateFlags operator&(MemoryAllocateFlags a, MemoryAllocateFlags b) {
    return static_cast<MemoryAllocateFlags>(static_cast<uint32_t>(a) & static_cast<uint32_t>(b));
}
inline constexpr MemoryAllocateFlags operator|(MemoryAllocateFlags a, MemoryAllocateFlags b) {
    return static_cast<MemoryAllocateFlags>(static_cast<uint32_t>(a) | static_cast<uint32_t>(b));
}

enum class MemoryHeapFlags {
    None = 0,
    DeviceLocal = 1u << 0u,
    MultiInstance = 1u << 1u,
};
inline constexpr MemoryHeapFlags operator&(MemoryHeapFlags a, MemoryHeapFlags b) {
    return static_cast<MemoryHeapFlags>(static_cast<uint32_t>(a) & static_cast<uint32_t>(b));
}
inline constexpr MemoryHeapFlags operator|(MemoryHeapFlags a, MemoryHeapFlags b) {
    return static_cast<MemoryHeapFlags>(static_cast<uint32_t>(a) | static_cast<uint32_t>(b));
}

enum class MemoryPropertyFlags {
    None = 0,
    DeviceLocal = 1u << 0u,
    HostVisible = 1u << 1u,
    HostCoherent = 1u << 2u,
    HostCached = 1u << 3u,
    LazilyAllocated = 1u << 4u,
    Protected = 1u << 5u,
};
inline constexpr MemoryPropertyFlags operator&(MemoryPropertyFlags a, MemoryPropertyFlags b) {
    return static_cast<MemoryPropertyFlags>(static_cast<uint32_t>(a) & static_cast<uint32_t>(b));
}
inline constexpr MemoryPropertyFlags operator|(MemoryPropertyFlags a, MemoryPropertyFlags b) {
    return static_cast<MemoryPropertyFlags>(static_cast<uint32_t>(a) | static_cast<uint32_t>(b));
}

enum class ObjectType {
    Unknown = 0,
    Instance = 1,
    PhysicalDevice = 2,
    Device = 3,
    Queue = 4,
    Semaphore = 5,
    CommandBuffer = 6,
    Fence = 7,
    DeviceMemory = 8,
    Buffer = 9,
    Image = 10,
    Event = 11,
    QueryPool = 12,
    BufferView = 13,
    ImageView = 14,
    ShaderModule = 15,
    PipelineCache = 16,
    PipelineLayout = 17,
    RenderPass = 18,
    Pipeline = 19,
    DescriptorSetLayout = 20,
    Sampler = 21,
    DescriptorPool = 22,
    DescriptorSet = 23,
    Framebuffer = 24,
    CommandPool = 25,
    SamplerYcbcrConversion = 1000156000,
    DescriptorUpdateTemplate = 1000085000,
    SurfaceKHR = 1000000000,
    SwapchainKHR = 1000001000,
};

enum class PeerMemoryFeature {
    CopySrc = 1u << 0u,
    CopyDst = 1u << 1u,
    GenericSrc = 1u << 2u,
    GenericDst = 1u << 3u,
};
inline constexpr PeerMemoryFeature operator&(PeerMemoryFeature a, PeerMemoryFeature b) {
    return static_cast<PeerMemoryFeature>(static_cast<uint32_t>(a) & static_cast<uint32_t>(b));
}
inline constexpr PeerMemoryFeature operator|(PeerMemoryFeature a, PeerMemoryFeature b) {
    return static_cast<PeerMemoryFeature>(static_cast<uint32_t>(a) | static_cast<uint32_t>(b));
}

enum class PhysicalDeviceType {
    Other = 0,
    IntegratedGpu = 1,
    DiscreteGpu = 2,
    VirtualGpu = 3,
    Cpu = 4,
};

enum class PipelineBindPoint {
    Graphics = 0,
    Compute = 1,
};

enum class PipelineCacheHeaderVersion {
    One = 1,
};

enum class PipelineCreateFlags {
    None = 0,
    DisableOptimization = 1u << 0u,
    AllowDerivatives = 1u << 1u,
    Derivative = 1u << 2u,
    ViewIndexFromDeviceIndex = 1u << 3u,
    DispatchBase = 1u << 4u,
};
inline constexpr PipelineCreateFlags operator&(PipelineCreateFlags a, PipelineCreateFlags b) {
    return static_cast<PipelineCreateFlags>(static_cast<uint32_t>(a) & static_cast<uint32_t>(b));
}
inline constexpr PipelineCreateFlags operator|(PipelineCreateFlags a, PipelineCreateFlags b) {
    return static_cast<PipelineCreateFlags>(static_cast<uint32_t>(a) | static_cast<uint32_t>(b));
}

enum class PipelineStage {
    TopOfPipe = 1u << 0u,
    DrawIndirect = 1u << 1u,
    VertexInput = 1u << 2u,
    VertexShader = 1u << 3u,
    TessellationControlShader = 1u << 4u,
    TessellationEvaluationShader = 1u << 5u,
    GeometryShader = 1u << 6u,
    FragmentShader = 1u << 7u,
    EarlyFragmentTests = 1u << 8u,
    LateFragmentTests = 1u << 9u,
    ColorAttachmentOutput = 1u << 10u,
    ComputeShader = 1u << 11u,
    Transfer = 1u << 12u,
    BottomOfPipe = 1u << 13u,
    Host = 1u << 14u,
    AllGraphics = 1u << 15u,
    AllCommands = 1u << 16u,
};
inline constexpr PipelineStage operator&(PipelineStage a, PipelineStage b) {
    return static_cast<PipelineStage>(static_cast<uint32_t>(a) & static_cast<uint32_t>(b));
}
inline constexpr PipelineStage operator|(PipelineStage a, PipelineStage b) {
    return static_cast<PipelineStage>(static_cast<uint32_t>(a) | static_cast<uint32_t>(b));
}

enum class PointClippingBehavior {
    AllClipPlanes = 0,
    UserClipPlanesOnly = 1,
};

enum class PolygonMode {
    Fill = 0,
    Line = 1,
    Point = 2,
};

enum class PresentModeKHR {
    ImmediateKHR = 0,
    MailboxKHR = 1,
    FifoKHR = 2,
    FifoRelaxedKHR = 3,
};

enum class PrimitiveTopology {
    PointList = 0,
    LineList = 1,
    LineStrip = 2,
    TriangleList = 3,
    TriangleStrip = 4,
    TriangleFan = 5,
    LineListWithAdjacency = 6,
    LineStripWithAdjacency = 7,
    TriangleListWithAdjacency = 8,
    TriangleStripWithAdjacency = 9,
    PatchList = 10,
};

enum class QueryControlFlags {
    None = 0,
    Precise = 1u << 0u,
};
inline constexpr QueryControlFlags operator&(QueryControlFlags a, QueryControlFlags b) {
    return static_cast<QueryControlFlags>(static_cast<uint32_t>(a) & static_cast<uint32_t>(b));
}
inline constexpr QueryControlFlags operator|(QueryControlFlags a, QueryControlFlags b) {
    return static_cast<QueryControlFlags>(static_cast<uint32_t>(a) | static_cast<uint32_t>(b));
}

enum class QueryPipelineStatisticFlags {
    None = 0,
    InputAssemblyVertices = 1u << 0u,
    InputAssemblyPrimitives = 1u << 1u,
    VertexShaderInvocations = 1u << 2u,
    GeometryShaderInvocations = 1u << 3u,
    GeometryShaderPrimitives = 1u << 4u,
    ClippingInvocations = 1u << 5u,
    ClippingPrimitives = 1u << 6u,
    FragmentShaderInvocations = 1u << 7u,
    TessellationControlShaderPatches = 1u << 8u,
    TessellationEvaluationShaderInvocations = 1u << 9u,
    ComputeShaderInvocations = 1u << 10u,
};
inline constexpr QueryPipelineStatisticFlags operator&(QueryPipelineStatisticFlags a, QueryPipelineStatisticFlags b) {
    return static_cast<QueryPipelineStatisticFlags>(static_cast<uint32_t>(a) & static_cast<uint32_t>(b));
}
inline constexpr QueryPipelineStatisticFlags operator|(QueryPipelineStatisticFlags a, QueryPipelineStatisticFlags b) {
    return static_cast<QueryPipelineStatisticFlags>(static_cast<uint32_t>(a) | static_cast<uint32_t>(b));
}

enum class QueryResultFlags {
    None = 0,
    _64 = 1u << 0u,
    Wait = 1u << 1u,
    WithAvailability = 1u << 2u,
    Partial = 1u << 3u,
};
inline constexpr QueryResultFlags operator&(QueryResultFlags a, QueryResultFlags b) {
    return static_cast<QueryResultFlags>(static_cast<uint32_t>(a) & static_cast<uint32_t>(b));
}
inline constexpr QueryResultFlags operator|(QueryResultFlags a, QueryResultFlags b) {
    return static_cast<QueryResultFlags>(static_cast<uint32_t>(a) | static_cast<uint32_t>(b));
}

enum class QueryType {
    Occlusion = 0,
    PipelineStatistics = 1,
    Timestamp = 2,
};

enum class QueueFlags {
    None = 0,
    Graphics = 1u << 0u,
    Compute = 1u << 1u,
    Transfer = 1u << 2u,
    SparseBinding = 1u << 3u,
    Protected = 1u << 4u,
};
inline constexpr QueueFlags operator&(QueueFlags a, QueueFlags b) {
    return static_cast<QueueFlags>(static_cast<uint32_t>(a) & static_cast<uint32_t>(b));
}
inline constexpr QueueFlags operator|(QueueFlags a, QueueFlags b) {
    return static_cast<QueueFlags>(static_cast<uint32_t>(a) | static_cast<uint32_t>(b));
}

enum class RenderingFlagBitsKHR {
    ContentsSecondaryCommandBuffersKHR = 1u << 0u,
    SuspendingKHR = 1u << 1u,
    ResumingKHR = 1u << 2u,
};
inline constexpr RenderingFlagBitsKHR operator&(RenderingFlagBitsKHR a, RenderingFlagBitsKHR b) {
    return static_cast<RenderingFlagBitsKHR>(static_cast<uint32_t>(a) & static_cast<uint32_t>(b));
}
inline constexpr RenderingFlagBitsKHR operator|(RenderingFlagBitsKHR a, RenderingFlagBitsKHR b) {
    return static_cast<RenderingFlagBitsKHR>(static_cast<uint32_t>(a) | static_cast<uint32_t>(b));
}

enum class ResolveMode {
    None = 0,
    SampleZero = 1u << 0u,
    Average = 1u << 1u,
    Min = 1u << 2u,
    Max = 1u << 3u,
};
inline constexpr ResolveMode operator&(ResolveMode a, ResolveMode b) {
    return static_cast<ResolveMode>(static_cast<uint32_t>(a) & static_cast<uint32_t>(b));
}
inline constexpr ResolveMode operator|(ResolveMode a, ResolveMode b) {
    return static_cast<ResolveMode>(static_cast<uint32_t>(a) | static_cast<uint32_t>(b));
}

enum class Result {
    Success = 0,
    NotReady = 1,
    Timeout = 2,
    EventSet = 3,
    EventReset = 4,
    Incomplete = 5,
    ErrorOutOfHostMemory = -1,
    ErrorOutOfDeviceMemory = -2,
    ErrorInitializationFailed = -3,
    ErrorDeviceLost = -4,
    ErrorMemoryMapFailed = -5,
    ErrorLayerNotPresent = -6,
    ErrorExtensionNotPresent = -7,
    ErrorFeatureNotPresent = -8,
    ErrorIncompatibleDriver = -9,
    ErrorTooManyObjects = -10,
    ErrorFormatNotSupported = -11,
    ErrorFragmentedPool = -12,
    ErrorUnknown = -13,
    ErrorOutOfPoolMemory = -1000069000,
    ErrorInvalidExternalHandle = -1000072003,
    ErrorFragmentation = -1000161000,
    ErrorInvalidOpaqueCaptureAddress = -1000257000,
    ErrorSurfaceLostKHR = -1000000000,
    ErrorNativeWindowInUseKHR = -1000000001,
    SuboptimalKHR = 1000001003,
    ErrorOutOfDateKHR = -1000001004,
};

enum class SampleCount {
    _1 = 1u << 0u,
    _2 = 1u << 1u,
    _4 = 1u << 2u,
    _8 = 1u << 3u,
    _16 = 1u << 4u,
    _32 = 1u << 5u,
    _64 = 1u << 6u,
};
inline constexpr SampleCount operator&(SampleCount a, SampleCount b) {
    return static_cast<SampleCount>(static_cast<uint32_t>(a) & static_cast<uint32_t>(b));
}
inline constexpr SampleCount operator|(SampleCount a, SampleCount b) {
    return static_cast<SampleCount>(static_cast<uint32_t>(a) | static_cast<uint32_t>(b));
}

enum class SamplerAddressMode {
    Repeat = 0,
    MirroredRepeat = 1,
    ClampToEdge = 2,
    ClampToBorder = 3,
    MirrorClampToEdge = 4,
};

enum class SamplerMipmapMode {
    Nearest = 0,
    Linear = 1,
};

enum class SamplerReductionMode {
    WeightedAverage = 0,
    Min = 1,
    Max = 2,
};

enum class SamplerYcbcrModelConversion {
    RgbIdentity = 0,
    YcbcrIdentity = 1,
    Ycbcr709 = 2,
    Ycbcr601 = 3,
    Ycbcr2020 = 4,
};

enum class SamplerYcbcrRange {
    ItuFull = 0,
    ItuNarrow = 1,
};

enum class SemaphoreImportFlags {
    None = 0,
    Temporary = 1u << 0u,
};
inline constexpr SemaphoreImportFlags operator&(SemaphoreImportFlags a, SemaphoreImportFlags b) {
    return static_cast<SemaphoreImportFlags>(static_cast<uint32_t>(a) & static_cast<uint32_t>(b));
}
inline constexpr SemaphoreImportFlags operator|(SemaphoreImportFlags a, SemaphoreImportFlags b) {
    return static_cast<SemaphoreImportFlags>(static_cast<uint32_t>(a) | static_cast<uint32_t>(b));
}

enum class SemaphoreType {
    Binary = 0,
    Timeline = 1,
};

enum class SemaphoreWaitFlags {
    None = 0,
    Any = 1u << 0u,
};
inline constexpr SemaphoreWaitFlags operator&(SemaphoreWaitFlags a, SemaphoreWaitFlags b) {
    return static_cast<SemaphoreWaitFlags>(static_cast<uint32_t>(a) & static_cast<uint32_t>(b));
}
inline constexpr SemaphoreWaitFlags operator|(SemaphoreWaitFlags a, SemaphoreWaitFlags b) {
    return static_cast<SemaphoreWaitFlags>(static_cast<uint32_t>(a) | static_cast<uint32_t>(b));
}

enum class ShaderFloatControlsIndependence {
    _32Only = 0,
    All = 1,
    None = 2,
};

enum class ShaderStage {
    Vertex = 1u << 0u,
    TessellationControl = 1u << 1u,
    TessellationEvaluation = 1u << 2u,
    Geometry = 1u << 3u,
    Fragment = 1u << 4u,
    Compute = 1u << 5u,
    AllGraphics = 0x0000001F,
    All = 0x7FFFFFFF,
};
inline constexpr ShaderStage operator&(ShaderStage a, ShaderStage b) {
    return static_cast<ShaderStage>(static_cast<uint32_t>(a) & static_cast<uint32_t>(b));
}
inline constexpr ShaderStage operator|(ShaderStage a, ShaderStage b) {
    return static_cast<ShaderStage>(static_cast<uint32_t>(a) | static_cast<uint32_t>(b));
}

enum class SharingMode {
    Exclusive = 0,
    Concurrent = 1,
};

enum class SparseImageFormatFlags {
    None = 0,
    SingleMiptail = 1u << 0u,
    AlignedMipSize = 1u << 1u,
    NonstandardBlockSize = 1u << 2u,
};
inline constexpr SparseImageFormatFlags operator&(SparseImageFormatFlags a, SparseImageFormatFlags b) {
    return static_cast<SparseImageFormatFlags>(static_cast<uint32_t>(a) & static_cast<uint32_t>(b));
}
inline constexpr SparseImageFormatFlags operator|(SparseImageFormatFlags a, SparseImageFormatFlags b) {
    return static_cast<SparseImageFormatFlags>(static_cast<uint32_t>(a) | static_cast<uint32_t>(b));
}

enum class SparseMemoryBindFlags {
    None = 0,
    Metadata = 1u << 0u,
};
inline constexpr SparseMemoryBindFlags operator&(SparseMemoryBindFlags a, SparseMemoryBindFlags b) {
    return static_cast<SparseMemoryBindFlags>(static_cast<uint32_t>(a) & static_cast<uint32_t>(b));
}
inline constexpr SparseMemoryBindFlags operator|(SparseMemoryBindFlags a, SparseMemoryBindFlags b) {
    return static_cast<SparseMemoryBindFlags>(static_cast<uint32_t>(a) | static_cast<uint32_t>(b));
}

enum class StencilFaceFlags {
    None = 0,
    Front = 1u << 0u,
    Back = 1u << 1u,
    FrontAndBack = 0x00000003,
};
inline constexpr StencilFaceFlags operator&(StencilFaceFlags a, StencilFaceFlags b) {
    return static_cast<StencilFaceFlags>(static_cast<uint32_t>(a) & static_cast<uint32_t>(b));
}
inline constexpr StencilFaceFlags operator|(StencilFaceFlags a, StencilFaceFlags b) {
    return static_cast<StencilFaceFlags>(static_cast<uint32_t>(a) | static_cast<uint32_t>(b));
}

enum class StencilOp {
    Keep = 0,
    Zero = 1,
    Replace = 2,
    IncrementAndClamp = 3,
    DecrementAndClamp = 4,
    Invert = 5,
    IncrementAndWrap = 6,
    DecrementAndWrap = 7,
};

enum class StructureType {
    ApplicationInfo = 0,
    InstanceCreateInfo = 1,
    DeviceQueueCreateInfo = 2,
    DeviceCreateInfo = 3,
    SubmitInfo = 4,
    MemoryAllocateInfo = 5,
    MappedMemoryRange = 6,
    BindSparseInfo = 7,
    FenceCreateInfo = 8,
    SemaphoreCreateInfo = 9,
    EventCreateInfo = 10,
    QueryPoolCreateInfo = 11,
    BufferCreateInfo = 12,
    BufferViewCreateInfo = 13,
    ImageCreateInfo = 14,
    ImageViewCreateInfo = 15,
    ShaderModuleCreateInfo = 16,
    PipelineCacheCreateInfo = 17,
    PipelineShaderStageCreateInfo = 18,
    PipelineVertexInputStateCreateInfo = 19,
    PipelineInputAssemblyStateCreateInfo = 20,
    PipelineTessellationStateCreateInfo = 21,
    PipelineViewportStateCreateInfo = 22,
    PipelineRasterizationStateCreateInfo = 23,
    PipelineMultisampleStateCreateInfo = 24,
    PipelineDepthStencilStateCreateInfo = 25,
    PipelineColorBlendStateCreateInfo = 26,
    PipelineDynamicStateCreateInfo = 27,
    GraphicsPipelineCreateInfo = 28,
    ComputePipelineCreateInfo = 29,
    PipelineLayoutCreateInfo = 30,
    SamplerCreateInfo = 31,
    DescriptorSetLayoutCreateInfo = 32,
    DescriptorPoolCreateInfo = 33,
    DescriptorSetAllocateInfo = 34,
    WriteDescriptorSet = 35,
    CopyDescriptorSet = 36,
    FramebufferCreateInfo = 37,
    RenderPassCreateInfo = 38,
    CommandPoolCreateInfo = 39,
    CommandBufferAllocateInfo = 40,
    CommandBufferInheritanceInfo = 41,
    CommandBufferBeginInfo = 42,
    RenderPassBeginInfo = 43,
    BufferMemoryBarrier = 44,
    ImageMemoryBarrier = 45,
    MemoryBarrier = 46,
    LoaderInstanceCreateInfo = 47,
    LoaderDeviceCreateInfo = 48,
    PhysicalDeviceSubgroupProperties = 1000094000,
    BindBufferMemoryInfo = 1000157000,
    BindImageMemoryInfo = 1000157001,
    PhysicalDevice16StorageFeatures = 1000083000,
    MemoryDedicatedRequirements = 1000127000,
    MemoryDedicatedAllocateInfo = 1000127001,
    MemoryAllocateFlagsInfo = 1000060000,
    DeviceGroupRenderPassBeginInfo = 1000060003,
    DeviceGroupCommandBufferBeginInfo = 1000060004,
    DeviceGroupSubmitInfo = 1000060005,
    DeviceGroupBindSparseInfo = 1000060006,
    BindBufferMemoryDeviceGroupInfo = 1000060013,
    BindImageMemoryDeviceGroupInfo = 1000060014,
    PhysicalDeviceGroupProperties = 1000070000,
    DeviceGroupDeviceCreateInfo = 1000070001,
    BufferMemoryRequirementsInfo2 = 1000146000,
    ImageMemoryRequirementsInfo2 = 1000146001,
    ImageSparseMemoryRequirementsInfo2 = 1000146002,
    MemoryRequirements2 = 1000146003,
    SparseImageMemoryRequirements2 = 1000146004,
    PhysicalDeviceFeatures2 = 1000059000,
    PhysicalDeviceProperties2 = 1000059001,
    FormatProperties2 = 1000059002,
    ImageFormatProperties2 = 1000059003,
    PhysicalDeviceImageFormatInfo2 = 1000059004,
    QueueFamilyProperties2 = 1000059005,
    PhysicalDeviceMemoryProperties2 = 1000059006,
    SparseImageFormatProperties2 = 1000059007,
    PhysicalDeviceSparseImageFormatInfo2 = 1000059008,
    PhysicalDevicePointClippingProperties = 1000117000,
    RenderPassInputAttachmentAspectCreateInfo = 1000117001,
    ImageViewUsageCreateInfo = 1000117002,
    PipelineTessellationDomainOriginStateCreateInfo = 1000117003,
    RenderPassMultiviewCreateInfo = 1000053000,
    PhysicalDeviceMultiviewFeatures = 1000053001,
    PhysicalDeviceMultiviewProperties = 1000053002,
    PhysicalDeviceVariablePointersFeatures = 1000120000,
    ProtectedSubmitInfo = 1000145000,
    PhysicalDeviceProtectedMemoryFeatures = 1000145001,
    PhysicalDeviceProtectedMemoryProperties = 1000145002,
    DeviceQueueInfo2 = 1000145003,
    SamplerYcbcrConversionCreateInfo = 1000156000,
    SamplerYcbcrConversionInfo = 1000156001,
    BindImagePlaneMemoryInfo = 1000156002,
    ImagePlaneMemoryRequirementsInfo = 1000156003,
    PhysicalDeviceSamplerYcbcrConversionFeatures = 1000156004,
    SamplerYcbcrConversionImageFormatProperties = 1000156005,
    DescriptorUpdateTemplateCreateInfo = 1000085000,
    PhysicalDeviceExternalImageFormatInfo = 1000071000,
    ExternalImageFormatProperties = 1000071001,
    PhysicalDeviceExternalBufferInfo = 1000071002,
    ExternalBufferProperties = 1000071003,
    PhysicalDeviceIdProperties = 1000071004,
    ExternalMemoryBufferCreateInfo = 1000072000,
    ExternalMemoryImageCreateInfo = 1000072001,
    ExportMemoryAllocateInfo = 1000072002,
    PhysicalDeviceExternalFenceInfo = 1000112000,
    ExternalFenceProperties = 1000112001,
    ExportFenceCreateInfo = 1000113000,
    ExportSemaphoreCreateInfo = 1000077000,
    PhysicalDeviceExternalSemaphoreInfo = 1000076000,
    ExternalSemaphoreProperties = 1000076001,
    PhysicalDeviceMaintenance3Properties = 1000168000,
    DescriptorSetLayoutSupport = 1000168001,
    PhysicalDeviceShaderDrawParametersFeatures = 1000063000,
    PhysicalDeviceVulkan11Features = 49,
    PhysicalDeviceVulkan11Properties = 50,
    PhysicalDeviceVulkan12Features = 51,
    PhysicalDeviceVulkan12Properties = 52,
    ImageFormatListCreateInfo = 1000147000,
    AttachmentDescription2 = 1000109000,
    AttachmentReference2 = 1000109001,
    SubpassDescription2 = 1000109002,
    SubpassDependency2 = 1000109003,
    RenderPassCreateInfo2 = 1000109004,
    SubpassBeginInfo = 1000109005,
    SubpassEndInfo = 1000109006,
    PhysicalDevice8StorageFeatures = 1000177000,
    PhysicalDeviceDriverProperties = 1000196000,
    PhysicalDeviceShaderAtomicInt64Features = 1000180000,
    PhysicalDeviceShaderFloat16Int8Features = 1000082000,
    PhysicalDeviceFloatControlsProperties = 1000197000,
    DescriptorSetLayoutBindingFlagsCreateInfo = 1000161000,
    PhysicalDeviceDescriptorIndexingFeatures = 1000161001,
    PhysicalDeviceDescriptorIndexingProperties = 1000161002,
    DescriptorSetVariableDescriptorCountAllocateInfo = 1000161003,
    DescriptorSetVariableDescriptorCountLayoutSupport = 1000161004,
    PhysicalDeviceDepthStencilResolveProperties = 1000199000,
    SubpassDescriptionDepthStencilResolve = 1000199001,
    PhysicalDeviceScalarBlockLayoutFeatures = 1000221000,
    ImageStencilUsageCreateInfo = 1000246000,
    PhysicalDeviceSamplerFilterMinmaxProperties = 1000130000,
    SamplerReductionModeCreateInfo = 1000130001,
    PhysicalDeviceVulkanMemoryModelFeatures = 1000211000,
    PhysicalDeviceImagelessFramebufferFeatures = 1000108000,
    FramebufferAttachmentsCreateInfo = 1000108001,
    FramebufferAttachmentImageInfo = 1000108002,
    RenderPassAttachmentBeginInfo = 1000108003,
    PhysicalDeviceUniformBufferStandardLayoutFeatures = 1000253000,
    PhysicalDeviceShaderSubgroupExtendedTypesFeatures = 1000175000,
    PhysicalDeviceSeparateDepthStencilLayoutsFeatures = 1000241000,
    AttachmentReferenceStencilLayout = 1000241001,
    AttachmentDescriptionStencilLayout = 1000241002,
    PhysicalDeviceHostQueryResetFeatures = 1000261000,
    PhysicalDeviceTimelineSemaphoreFeatures = 1000207000,
    PhysicalDeviceTimelineSemaphoreProperties = 1000207001,
    SemaphoreTypeCreateInfo = 1000207002,
    TimelineSemaphoreSubmitInfo = 1000207003,
    SemaphoreWaitInfo = 1000207004,
    SemaphoreSignalInfo = 1000207005,
    PhysicalDeviceBufferDeviceAddressFeatures = 1000257000,
    BufferDeviceAddressInfo = 1000244001,
    BufferOpaqueCaptureAddressCreateInfo = 1000257002,
    MemoryOpaqueCaptureAddressAllocateInfo = 1000257003,
    DeviceMemoryOpaqueCaptureAddressInfo = 1000257004,
    PhysicalDeviceShaderAtomicFloat2FeaturesEXT = 1000273000,
    RenderingInfoKHR = 1000044000,
    RenderingAttachmentInfoKHR = 1000044001,
    PipelineRenderingCreateInfoKHR = 1000044002,
    PhysicalDeviceDynamicRenderingFeaturesKHR = 1000044003,
    CommandBufferInheritanceRenderingInfoKHR = 1000044004,
    SwapchainCreateInfoKHR = 1000001000,
    PresentInfoKHR = 1000001001,
    DeviceGroupPresentCapabilitiesKHR = 1000060007,
    ImageSwapchainCreateInfoKHR = 1000060008,
    BindImageMemorySwapchainInfoKHR = 1000060009,
    AcquireNextImageInfoKHR = 1000060010,
    DeviceGroupPresentInfoKHR = 1000060011,
    DeviceGroupSwapchainCreateInfoKHR = 1000060012,
    XcbSurfaceCreateInfoKHR = 1000005000,
    PhysicalDeviceShaderAtomicFloatFeaturesEXT = 1000260000,
};

enum class SubgroupFeature {
    Basic = 1u << 0u,
    Vote = 1u << 1u,
    Arithmetic = 1u << 2u,
    Ballot = 1u << 3u,
    Shuffle = 1u << 4u,
    ShuffleRelative = 1u << 5u,
    Clustered = 1u << 6u,
    Quad = 1u << 7u,
};
inline constexpr SubgroupFeature operator&(SubgroupFeature a, SubgroupFeature b) {
    return static_cast<SubgroupFeature>(static_cast<uint32_t>(a) & static_cast<uint32_t>(b));
}
inline constexpr SubgroupFeature operator|(SubgroupFeature a, SubgroupFeature b) {
    return static_cast<SubgroupFeature>(static_cast<uint32_t>(a) | static_cast<uint32_t>(b));
}

enum class SubpassContents {
    Inline = 0,
    SecondaryCommandBuffers = 1,
};

enum class SurfaceTransformFlagBitsKHR {
    IdentityKHR = 1u << 0u,
    Rotate90KHR = 1u << 1u,
    Rotate180KHR = 1u << 2u,
    Rotate270KHR = 1u << 3u,
    HorizontalMirrorKHR = 1u << 4u,
    HorizontalMirrorRotate90KHR = 1u << 5u,
    HorizontalMirrorRotate180KHR = 1u << 6u,
    HorizontalMirrorRotate270KHR = 1u << 7u,
    InheritKHR = 1u << 8u,
};
inline constexpr SurfaceTransformFlagBitsKHR operator&(SurfaceTransformFlagBitsKHR a, SurfaceTransformFlagBitsKHR b) {
    return static_cast<SurfaceTransformFlagBitsKHR>(static_cast<uint32_t>(a) & static_cast<uint32_t>(b));
}
inline constexpr SurfaceTransformFlagBitsKHR operator|(SurfaceTransformFlagBitsKHR a, SurfaceTransformFlagBitsKHR b) {
    return static_cast<SurfaceTransformFlagBitsKHR>(static_cast<uint32_t>(a) | static_cast<uint32_t>(b));
}

enum class SwapchainCreateFlagBitsKHR {
    SplitInstanceBindRegionsKHR = 1u << 0u,
    ProtectedKHR = 1u << 1u,
};
inline constexpr SwapchainCreateFlagBitsKHR operator&(SwapchainCreateFlagBitsKHR a, SwapchainCreateFlagBitsKHR b) {
    return static_cast<SwapchainCreateFlagBitsKHR>(static_cast<uint32_t>(a) & static_cast<uint32_t>(b));
}
inline constexpr SwapchainCreateFlagBitsKHR operator|(SwapchainCreateFlagBitsKHR a, SwapchainCreateFlagBitsKHR b) {
    return static_cast<SwapchainCreateFlagBitsKHR>(static_cast<uint32_t>(a) | static_cast<uint32_t>(b));
}

enum class SystemAllocationScope {
    Command = 0,
    Object = 1,
    Cache = 2,
    Device = 3,
    Instance = 4,
};

enum class TessellationDomainOrigin {
    UpperLeft = 0,
    LowerLeft = 1,
};

enum class VendorId {
    VIV = 0x10001,
    VSI = 0x10002,
    Kazan = 0x10003,
    Codeplay = 0x10004,
    MESA = 0x10005,
    Pocl = 0x10006,
};

enum class VertexInputRate {
    Vertex = 0,
    Instance = 1,
};

// Function pointers.
// NOLINTNEXTLINE
typedef void* (VKAPI_PTR *PFN_vkAllocationFunction)(
    void*                                       pUserData,
    size_t                                      size,
    size_t                                      alignment,
    SystemAllocationScope                     allocationScope);
// NOLINTNEXTLINE
typedef void (VKAPI_PTR *PFN_vkFreeFunction)(
    void*                                       pUserData,
    void*                                       pMemory);
// NOLINTNEXTLINE
typedef void (VKAPI_PTR *PFN_vkInternalAllocationNotification)(
    void*                                       pUserData,
    size_t                                      size,
    InternalAllocationType                    allocationType,
    SystemAllocationScope                     allocationScope);
// NOLINTNEXTLINE
typedef void (VKAPI_PTR *PFN_vkInternalFreeNotification)(
    void*                                       pUserData,
    size_t                                      size,
    InternalAllocationType                    allocationType,
    SystemAllocationScope                     allocationScope);
// NOLINTNEXTLINE
typedef void* (VKAPI_PTR *PFN_vkReallocationFunction)(
    void*                                       pUserData,
    void*                                       pOriginal,
    size_t                                      size,
    size_t                                      alignment,
    SystemAllocationScope                     allocationScope);
// NOLINTNEXTLINE
typedef void (VKAPI_PTR *PFN_vkVoidFunction)(void);

// Structs and unions.
struct Extent2D {
    uint32_t width;
    uint32_t height;
};

struct Extent3D {
    uint32_t width;
    uint32_t height;
    uint32_t depth;
};

struct Offset2D {
    int32_t x;
    int32_t y;
};

struct Offset3D {
    int32_t x;
    int32_t y;
    int32_t z;
};

struct Rect2D {
    Offset2D offset;
    Extent2D extent;
};

struct BaseInStructure {
    StructureType sType;
    const struct BaseInStructure *pNext;
};

struct BaseOutStructure {
    StructureType sType;
    struct BaseOutStructure *pNext;
};

struct BufferMemoryBarrier {
    StructureType sType;
    const void *pNext;
    Access srcAccessMask;
    Access dstAccessMask;
    uint32_t srcQueueFamilyIndex;
    uint32_t dstQueueFamilyIndex;
    Buffer buffer;
    DeviceSize offset;
    DeviceSize size;
};

struct DispatchIndirectCommand {
    uint32_t x;
    uint32_t y;
    uint32_t z;
};

struct DrawIndexedIndirectCommand {
    uint32_t indexCount;
    uint32_t instanceCount;
    uint32_t firstIndex;
    int32_t vertexOffset;
    uint32_t firstInstance;
};

struct DrawIndirectCommand {
    uint32_t vertexCount;
    uint32_t instanceCount;
    uint32_t firstVertex;
    uint32_t firstInstance;
};

struct ImageSubresourceRange {
    ImageAspect aspectMask;
    uint32_t baseMipLevel;
    uint32_t levelCount;
    uint32_t baseArrayLayer;
    uint32_t layerCount;
};

struct ImageMemoryBarrier {
    StructureType sType;
    const void *pNext;
    Access srcAccessMask;
    Access dstAccessMask;
    ImageLayout oldLayout;
    ImageLayout newLayout;
    uint32_t srcQueueFamilyIndex;
    uint32_t dstQueueFamilyIndex;
    Image image;
    ImageSubresourceRange subresourceRange;
};

struct MemoryBarrier {
    StructureType sType;
    const void *pNext;
    Access srcAccessMask;
    Access dstAccessMask;
};

struct PipelineCacheHeaderVersionOne {
    uint32_t headerSize;
    PipelineCacheHeaderVersion headerVersion;
    uint32_t vendorID;
    uint32_t deviceID;
    // NOLINTNEXTLINE
    uint8_t pipelineCacheUUID [VK_UUID_SIZE ];
};

struct AllocationCallbacks {
    void *pUserData;
    PFN_vkAllocationFunction pfnAllocation;
    PFN_vkReallocationFunction pfnReallocation;
    PFN_vkFreeFunction pfnFree;
    PFN_vkInternalAllocationNotification pfnInternalAllocation;
    PFN_vkInternalFreeNotification pfnInternalFree;
};

struct ApplicationInfo {
    StructureType sType;
    const void *pNext;
    const char *pApplicationName;
    uint32_t applicationVersion;
    const char *pEngineName;
    uint32_t engineVersion;
    uint32_t apiVersion;
};

struct FormatProperties {
    FormatFeature linearTilingFeatures;
    FormatFeature optimalTilingFeatures;
    FormatFeature bufferFeatures;
};

struct ImageFormatProperties {
    Extent3D maxExtent;
    uint32_t maxMipLevels;
    uint32_t maxArrayLayers;
    SampleCount sampleCounts;
    DeviceSize maxResourceSize;
};

struct InstanceCreateInfo {
    StructureType sType;
    const void *pNext;
    InstanceCreateFlags flags;
    const ApplicationInfo *pApplicationInfo;
    uint32_t enabledLayerCount;
    const char * const*ppEnabledLayerNames;
    uint32_t enabledExtensionCount;
    const char * const*ppEnabledExtensionNames;
};

struct MemoryHeap {
    DeviceSize size;
    MemoryHeapFlags flags;
};

struct MemoryType {
    MemoryPropertyFlags propertyFlags;
    uint32_t heapIndex;
};

struct PhysicalDeviceFeatures {
    Bool32 robustBufferAccess;
    Bool32 fullDrawIndexUint32;
    Bool32 imageCubeArray;
    Bool32 independentBlend;
    Bool32 geometryShader;
    Bool32 tessellationShader;
    Bool32 sampleRateShading;
    Bool32 dualSrcBlend;
    Bool32 logicOp;
    Bool32 multiDrawIndirect;
    Bool32 drawIndirectFirstInstance;
    Bool32 depthClamp;
    Bool32 depthBiasClamp;
    Bool32 fillModeNonSolid;
    Bool32 depthBounds;
    Bool32 wideLines;
    Bool32 largePoints;
    Bool32 alphaToOne;
    Bool32 multiViewport;
    Bool32 samplerAnisotropy;
    Bool32 textureCompressionETC2;
    Bool32 textureCompressionASTC_LDR;
    Bool32 textureCompressionBC;
    Bool32 occlusionQueryPrecise;
    Bool32 pipelineStatisticsQuery;
    Bool32 vertexPipelineStoresAndAtomics;
    Bool32 fragmentStoresAndAtomics;
    Bool32 shaderTessellationAndGeometryPointSize;
    Bool32 shaderImageGatherExtended;
    Bool32 shaderStorageImageExtendedFormats;
    Bool32 shaderStorageImageMultisample;
    Bool32 shaderStorageImageReadWithoutFormat;
    Bool32 shaderStorageImageWriteWithoutFormat;
    Bool32 shaderUniformBufferArrayDynamicIndexing;
    Bool32 shaderSampledImageArrayDynamicIndexing;
    Bool32 shaderStorageBufferArrayDynamicIndexing;
    Bool32 shaderStorageImageArrayDynamicIndexing;
    Bool32 shaderClipDistance;
    Bool32 shaderCullDistance;
    Bool32 shaderFloat64;
    Bool32 shaderInt64;
    Bool32 shaderInt16;
    Bool32 shaderResourceResidency;
    Bool32 shaderResourceMinLod;
    Bool32 sparseBinding;
    Bool32 sparseResidencyBuffer;
    Bool32 sparseResidencyImage2D;
    Bool32 sparseResidencyImage3D;
    Bool32 sparseResidency2Samples;
    Bool32 sparseResidency4Samples;
    Bool32 sparseResidency8Samples;
    Bool32 sparseResidency16Samples;
    Bool32 sparseResidencyAliased;
    Bool32 variableMultisampleRate;
    Bool32 inheritedQueries;
};

struct PhysicalDeviceLimits {
    uint32_t maxImageDimension1D;
    uint32_t maxImageDimension2D;
    uint32_t maxImageDimension3D;
    uint32_t maxImageDimensionCube;
    uint32_t maxImageArrayLayers;
    uint32_t maxTexelBufferElements;
    uint32_t maxUniformBufferRange;
    uint32_t maxStorageBufferRange;
    uint32_t maxPushConstantsSize;
    uint32_t maxMemoryAllocationCount;
    uint32_t maxSamplerAllocationCount;
    DeviceSize bufferImageGranularity;
    DeviceSize sparseAddressSpaceSize;
    uint32_t maxBoundDescriptorSets;
    uint32_t maxPerStageDescriptorSamplers;
    uint32_t maxPerStageDescriptorUniformBuffers;
    uint32_t maxPerStageDescriptorStorageBuffers;
    uint32_t maxPerStageDescriptorSampledImages;
    uint32_t maxPerStageDescriptorStorageImages;
    uint32_t maxPerStageDescriptorInputAttachments;
    uint32_t maxPerStageResources;
    uint32_t maxDescriptorSetSamplers;
    uint32_t maxDescriptorSetUniformBuffers;
    uint32_t maxDescriptorSetUniformBuffersDynamic;
    uint32_t maxDescriptorSetStorageBuffers;
    uint32_t maxDescriptorSetStorageBuffersDynamic;
    uint32_t maxDescriptorSetSampledImages;
    uint32_t maxDescriptorSetStorageImages;
    uint32_t maxDescriptorSetInputAttachments;
    uint32_t maxVertexInputAttributes;
    uint32_t maxVertexInputBindings;
    uint32_t maxVertexInputAttributeOffset;
    uint32_t maxVertexInputBindingStride;
    uint32_t maxVertexOutputComponents;
    uint32_t maxTessellationGenerationLevel;
    uint32_t maxTessellationPatchSize;
    uint32_t maxTessellationControlPerVertexInputComponents;
    uint32_t maxTessellationControlPerVertexOutputComponents;
    uint32_t maxTessellationControlPerPatchOutputComponents;
    uint32_t maxTessellationControlTotalOutputComponents;
    uint32_t maxTessellationEvaluationInputComponents;
    uint32_t maxTessellationEvaluationOutputComponents;
    uint32_t maxGeometryShaderInvocations;
    uint32_t maxGeometryInputComponents;
    uint32_t maxGeometryOutputComponents;
    uint32_t maxGeometryOutputVertices;
    uint32_t maxGeometryTotalOutputComponents;
    uint32_t maxFragmentInputComponents;
    uint32_t maxFragmentOutputAttachments;
    uint32_t maxFragmentDualSrcAttachments;
    uint32_t maxFragmentCombinedOutputResources;
    uint32_t maxComputeSharedMemorySize;
    // NOLINTNEXTLINE
    uint32_t maxComputeWorkGroupCount [3];
    uint32_t maxComputeWorkGroupInvocations;
    // NOLINTNEXTLINE
    uint32_t maxComputeWorkGroupSize [3];
    uint32_t subPixelPrecisionBits;
    uint32_t subTexelPrecisionBits;
    uint32_t mipmapPrecisionBits;
    uint32_t maxDrawIndexedIndexValue;
    uint32_t maxDrawIndirectCount;
    float maxSamplerLodBias;
    float maxSamplerAnisotropy;
    uint32_t maxViewports;
    // NOLINTNEXTLINE
    uint32_t maxViewportDimensions [2];
    // NOLINTNEXTLINE
    float viewportBoundsRange [2];
    uint32_t viewportSubPixelBits;
    size_t minMemoryMapAlignment;
    DeviceSize minTexelBufferOffsetAlignment;
    DeviceSize minUniformBufferOffsetAlignment;
    DeviceSize minStorageBufferOffsetAlignment;
    int32_t minTexelOffset;
    uint32_t maxTexelOffset;
    int32_t minTexelGatherOffset;
    uint32_t maxTexelGatherOffset;
    float minInterpolationOffset;
    float maxInterpolationOffset;
    uint32_t subPixelInterpolationOffsetBits;
    uint32_t maxFramebufferWidth;
    uint32_t maxFramebufferHeight;
    uint32_t maxFramebufferLayers;
    SampleCount framebufferColorSampleCounts;
    SampleCount framebufferDepthSampleCounts;
    SampleCount framebufferStencilSampleCounts;
    SampleCount framebufferNoAttachmentsSampleCounts;
    uint32_t maxColorAttachments;
    SampleCount sampledImageColorSampleCounts;
    SampleCount sampledImageIntegerSampleCounts;
    SampleCount sampledImageDepthSampleCounts;
    SampleCount sampledImageStencilSampleCounts;
    SampleCount storageImageSampleCounts;
    uint32_t maxSampleMaskWords;
    Bool32 timestampComputeAndGraphics;
    float timestampPeriod;
    uint32_t maxClipDistances;
    uint32_t maxCullDistances;
    uint32_t maxCombinedClipAndCullDistances;
    uint32_t discreteQueuePriorities;
    // NOLINTNEXTLINE
    float pointSizeRange [2];
    // NOLINTNEXTLINE
    float lineWidthRange [2];
    float pointSizeGranularity;
    float lineWidthGranularity;
    Bool32 strictLines;
    Bool32 standardSampleLocations;
    DeviceSize optimalBufferCopyOffsetAlignment;
    DeviceSize optimalBufferCopyRowPitchAlignment;
    DeviceSize nonCoherentAtomSize;
};

struct PhysicalDeviceMemoryProperties {
    uint32_t memoryTypeCount;
    // NOLINTNEXTLINE
    MemoryType memoryTypes [VK_MAX_MEMORY_TYPES ];
    uint32_t memoryHeapCount;
    // NOLINTNEXTLINE
    MemoryHeap memoryHeaps [VK_MAX_MEMORY_HEAPS ];
};

struct PhysicalDeviceSparseProperties {
    Bool32 residencyStandard2DBlockShape;
    Bool32 residencyStandard2DMultisampleBlockShape;
    Bool32 residencyStandard3DBlockShape;
    Bool32 residencyAlignedMipSize;
    Bool32 residencyNonResidentStrict;
};

struct PhysicalDeviceProperties {
    uint32_t apiVersion;
    uint32_t driverVersion;
    uint32_t vendorID;
    uint32_t deviceID;
    PhysicalDeviceType deviceType;
    // NOLINTNEXTLINE
    char deviceName [VK_MAX_PHYSICAL_DEVICE_NAME_SIZE ];
    // NOLINTNEXTLINE
    uint8_t pipelineCacheUUID [VK_UUID_SIZE ];
    PhysicalDeviceLimits limits;
    PhysicalDeviceSparseProperties sparseProperties;
};

struct QueueFamilyProperties {
    QueueFlags queueFlags;
    uint32_t queueCount;
    uint32_t timestampValidBits;
    Extent3D minImageTransferGranularity;
};

struct DeviceQueueCreateInfo {
    StructureType sType;
    const void *pNext;
    DeviceQueueCreateFlags flags;
    uint32_t queueFamilyIndex;
    uint32_t queueCount;
    const float *pQueuePriorities;
};

struct DeviceCreateInfo {
    StructureType sType;
    const void *pNext;
    DeviceCreateFlags flags;
    uint32_t queueCreateInfoCount;
    const DeviceQueueCreateInfo *pQueueCreateInfos;
    uint32_t enabledLayerCount;
    const char * const*ppEnabledLayerNames;
    uint32_t enabledExtensionCount;
    const char * const*ppEnabledExtensionNames;
    const PhysicalDeviceFeatures *pEnabledFeatures;
};

struct ExtensionProperties {
    // NOLINTNEXTLINE
    char extensionName [VK_MAX_EXTENSION_NAME_SIZE ];
    uint32_t specVersion;
};

struct LayerProperties {
    // NOLINTNEXTLINE
    char layerName [VK_MAX_EXTENSION_NAME_SIZE ];
    uint32_t specVersion;
    uint32_t implementationVersion;
    // NOLINTNEXTLINE
    char description [VK_MAX_DESCRIPTION_SIZE ];
};

struct SubmitInfo {
    StructureType sType;
    const void *pNext;
    uint32_t waitSemaphoreCount;
    const Semaphore *pWaitSemaphores;
    const PipelineStage *pWaitDstStageMask;
    uint32_t commandBufferCount;
    const CommandBuffer *pCommandBuffers;
    uint32_t signalSemaphoreCount;
    const Semaphore *pSignalSemaphores;
};

struct MappedMemoryRange {
    StructureType sType;
    const void *pNext;
    DeviceMemory memory;
    DeviceSize offset;
    DeviceSize size;
};

struct MemoryAllocateInfo {
    StructureType sType;
    const void *pNext;
    DeviceSize allocationSize;
    uint32_t memoryTypeIndex;
};

struct MemoryRequirements {
    DeviceSize size;
    DeviceSize alignment;
    uint32_t memoryTypeBits;
};

struct SparseMemoryBind {
    DeviceSize resourceOffset;
    DeviceSize size;
    DeviceMemory memory;
    DeviceSize memoryOffset;
    SparseMemoryBindFlags flags;
};

struct SparseBufferMemoryBindInfo {
    Buffer buffer;
    uint32_t bindCount;
    const SparseMemoryBind *pBinds;
};

struct SparseImageOpaqueMemoryBindInfo {
    Image image;
    uint32_t bindCount;
    const SparseMemoryBind *pBinds;
};

struct ImageSubresource {
    ImageAspect aspectMask;
    uint32_t mipLevel;
    uint32_t arrayLayer;
};

struct SparseImageMemoryBind {
    ImageSubresource subresource;
    Offset3D offset;
    Extent3D extent;
    DeviceMemory memory;
    DeviceSize memoryOffset;
    SparseMemoryBindFlags flags;
};

struct SparseImageMemoryBindInfo {
    Image image;
    uint32_t bindCount;
    const SparseImageMemoryBind *pBinds;
};

struct BindSparseInfo {
    StructureType sType;
    const void *pNext;
    uint32_t waitSemaphoreCount;
    const Semaphore *pWaitSemaphores;
    uint32_t bufferBindCount;
    const SparseBufferMemoryBindInfo *pBufferBinds;
    uint32_t imageOpaqueBindCount;
    const SparseImageOpaqueMemoryBindInfo *pImageOpaqueBinds;
    uint32_t imageBindCount;
    const SparseImageMemoryBindInfo *pImageBinds;
    uint32_t signalSemaphoreCount;
    const Semaphore *pSignalSemaphores;
};

struct SparseImageFormatProperties {
    ImageAspect aspectMask;
    Extent3D imageGranularity;
    SparseImageFormatFlags flags;
};

struct SparseImageMemoryRequirements {
    SparseImageFormatProperties formatProperties;
    uint32_t imageMipTailFirstLod;
    DeviceSize imageMipTailSize;
    DeviceSize imageMipTailOffset;
    DeviceSize imageMipTailStride;
};

struct FenceCreateInfo {
    StructureType sType;
    const void *pNext;
    FenceCreateFlags flags;
};

struct SemaphoreCreateInfo {
    StructureType sType;
    const void *pNext;
    SemaphoreCreateFlags flags;
};

struct EventCreateInfo {
    StructureType sType;
    const void *pNext;
    EventCreateFlags flags;
};

struct QueryPoolCreateInfo {
    StructureType sType;
    const void *pNext;
    QueryPoolCreateFlags flags;
    QueryType queryType;
    uint32_t queryCount;
    QueryPipelineStatisticFlags pipelineStatistics;
};

struct BufferCreateInfo {
    StructureType sType;
    const void *pNext;
    BufferCreateFlags flags;
    DeviceSize size;
    BufferUsage usage;
    SharingMode sharingMode;
    uint32_t queueFamilyIndexCount;
    const uint32_t *pQueueFamilyIndices;
};

struct BufferViewCreateInfo {
    StructureType sType;
    const void *pNext;
    BufferViewCreateFlags flags;
    Buffer buffer;
    Format format;
    DeviceSize offset;
    DeviceSize range;
};

struct ImageCreateInfo {
    StructureType sType;
    const void *pNext;
    ImageCreateFlags flags;
    ImageType imageType;
    Format format;
    Extent3D extent;
    uint32_t mipLevels;
    uint32_t arrayLayers;
    SampleCount samples;
    ImageTiling tiling;
    ImageUsage usage;
    SharingMode sharingMode;
    uint32_t queueFamilyIndexCount;
    const uint32_t *pQueueFamilyIndices;
    ImageLayout initialLayout;
};

struct SubresourceLayout {
    DeviceSize offset;
    DeviceSize size;
    DeviceSize rowPitch;
    DeviceSize arrayPitch;
    DeviceSize depthPitch;
};

struct ComponentMapping {
    ComponentSwizzle r;
    ComponentSwizzle g;
    ComponentSwizzle b;
    ComponentSwizzle a;
};

struct ImageViewCreateInfo {
    StructureType sType;
    const void *pNext;
    ImageViewCreateFlags flags;
    Image image;
    ImageViewType viewType;
    Format format;
    ComponentMapping components;
    ImageSubresourceRange subresourceRange;
};

struct ShaderModuleCreateInfo {
    StructureType sType;
    const void *pNext;
    ShaderModuleCreateFlags flags;
    size_t codeSize;
    const uint32_t *pCode;
};

struct PipelineCacheCreateInfo {
    StructureType sType;
    const void *pNext;
    PipelineCacheCreateFlags flags;
    size_t initialDataSize;
    const void *pInitialData;
};

struct SpecializationMapEntry {
    uint32_t constantID;
    uint32_t offset;
    size_t size;
};

struct SpecializationInfo {
    uint32_t mapEntryCount;
    const SpecializationMapEntry *pMapEntries;
    size_t dataSize;
    const void *pData;
};

struct PipelineShaderStageCreateInfo {
    StructureType sType;
    const void *pNext;
    PipelineShaderStageCreateFlags flags;
    ShaderStage stage;
    ShaderModule module;
    const char *pName;
    const SpecializationInfo *pSpecializationInfo;
};

struct ComputePipelineCreateInfo {
    StructureType sType;
    const void *pNext;
    PipelineCreateFlags flags;
    PipelineShaderStageCreateInfo stage;
    PipelineLayout layout;
    Pipeline basePipelineHandle;
    int32_t basePipelineIndex;
};

struct VertexInputBindingDescription {
    uint32_t binding;
    uint32_t stride;
    VertexInputRate inputRate;
};

struct VertexInputAttributeDescription {
    uint32_t location;
    uint32_t binding;
    Format format;
    uint32_t offset;
};

struct PipelineVertexInputStateCreateInfo {
    StructureType sType;
    const void *pNext;
    PipelineVertexInputStateCreateFlags flags;
    uint32_t vertexBindingDescriptionCount;
    const VertexInputBindingDescription *pVertexBindingDescriptions;
    uint32_t vertexAttributeDescriptionCount;
    const VertexInputAttributeDescription *pVertexAttributeDescriptions;
};

struct PipelineInputAssemblyStateCreateInfo {
    StructureType sType;
    const void *pNext;
    PipelineInputAssemblyStateCreateFlags flags;
    PrimitiveTopology topology;
    Bool32 primitiveRestartEnable;
};

struct PipelineTessellationStateCreateInfo {
    StructureType sType;
    const void *pNext;
    PipelineTessellationStateCreateFlags flags;
    uint32_t patchControlPoints;
};

struct Viewport {
    float x;
    float y;
    float width;
    float height;
    float minDepth;
    float maxDepth;
};

struct PipelineViewportStateCreateInfo {
    StructureType sType;
    const void *pNext;
    PipelineViewportStateCreateFlags flags;
    uint32_t viewportCount;
    const Viewport *pViewports;
    uint32_t scissorCount;
    const Rect2D *pScissors;
};

struct PipelineRasterizationStateCreateInfo {
    StructureType sType;
    const void *pNext;
    PipelineRasterizationStateCreateFlags flags;
    Bool32 depthClampEnable;
    Bool32 rasterizerDiscardEnable;
    PolygonMode polygonMode;
    CullMode cullMode;
    FrontFace frontFace;
    Bool32 depthBiasEnable;
    float depthBiasConstantFactor;
    float depthBiasClamp;
    float depthBiasSlopeFactor;
    float lineWidth;
};

struct PipelineMultisampleStateCreateInfo {
    StructureType sType;
    const void *pNext;
    PipelineMultisampleStateCreateFlags flags;
    SampleCount rasterizationSamples;
    Bool32 sampleShadingEnable;
    float minSampleShading;
    const SampleMask *pSampleMask;
    Bool32 alphaToCoverageEnable;
    Bool32 alphaToOneEnable;
};

struct StencilOpState {
    StencilOp failOp;
    StencilOp passOp;
    StencilOp depthFailOp;
    CompareOp compareOp;
    uint32_t compareMask;
    uint32_t writeMask;
    uint32_t reference;
};

struct PipelineDepthStencilStateCreateInfo {
    StructureType sType;
    const void *pNext;
    PipelineDepthStencilStateCreateFlags flags;
    Bool32 depthTestEnable;
    Bool32 depthWriteEnable;
    CompareOp depthCompareOp;
    Bool32 depthBoundsTestEnable;
    Bool32 stencilTestEnable;
    StencilOpState front;
    StencilOpState back;
    float minDepthBounds;
    float maxDepthBounds;
};

struct PipelineColorBlendAttachmentState {
    Bool32 blendEnable;
    BlendFactor srcColorBlendFactor;
    BlendFactor dstColorBlendFactor;
    BlendOp colorBlendOp;
    BlendFactor srcAlphaBlendFactor;
    BlendFactor dstAlphaBlendFactor;
    BlendOp alphaBlendOp;
    ColorComponent colorWriteMask;
};

struct PipelineColorBlendStateCreateInfo {
    StructureType sType;
    const void *pNext;
    PipelineColorBlendStateCreateFlags flags;
    Bool32 logicOpEnable;
    LogicOp logicOp;
    uint32_t attachmentCount;
    const PipelineColorBlendAttachmentState *pAttachments;
    // NOLINTNEXTLINE
    float blendConstants [4];
};

struct PipelineDynamicStateCreateInfo {
    StructureType sType;
    const void *pNext;
    PipelineDynamicStateCreateFlags flags;
    uint32_t dynamicStateCount;
    const DynamicState *pDynamicStates;
};

struct GraphicsPipelineCreateInfo {
    StructureType sType;
    const void *pNext;
    PipelineCreateFlags flags;
    uint32_t stageCount;
    const PipelineShaderStageCreateInfo *pStages;
    const PipelineVertexInputStateCreateInfo *pVertexInputState;
    const PipelineInputAssemblyStateCreateInfo *pInputAssemblyState;
    const PipelineTessellationStateCreateInfo *pTessellationState;
    const PipelineViewportStateCreateInfo *pViewportState;
    const PipelineRasterizationStateCreateInfo *pRasterizationState;
    const PipelineMultisampleStateCreateInfo *pMultisampleState;
    const PipelineDepthStencilStateCreateInfo *pDepthStencilState;
    const PipelineColorBlendStateCreateInfo *pColorBlendState;
    const PipelineDynamicStateCreateInfo *pDynamicState;
    PipelineLayout layout;
    RenderPass renderPass;
    uint32_t subpass;
    Pipeline basePipelineHandle;
    int32_t basePipelineIndex;
};

struct PushConstantRange {
    ShaderStage stageFlags;
    uint32_t offset;
    uint32_t size;
};

struct PipelineLayoutCreateInfo {
    StructureType sType;
    const void *pNext;
    PipelineLayoutCreateFlags flags;
    uint32_t setLayoutCount;
    const DescriptorSetLayout *pSetLayouts;
    uint32_t pushConstantRangeCount;
    const PushConstantRange *pPushConstantRanges;
};

struct SamplerCreateInfo {
    StructureType sType;
    const void *pNext;
    SamplerCreateFlags flags;
    Filter magFilter;
    Filter minFilter;
    SamplerMipmapMode mipmapMode;
    SamplerAddressMode addressModeU;
    SamplerAddressMode addressModeV;
    SamplerAddressMode addressModeW;
    float mipLodBias;
    Bool32 anisotropyEnable;
    float maxAnisotropy;
    Bool32 compareEnable;
    CompareOp compareOp;
    float minLod;
    float maxLod;
    BorderColor borderColor;
    Bool32 unnormalizedCoordinates;
};

struct CopyDescriptorSet {
    StructureType sType;
    const void *pNext;
    DescriptorSet srcSet;
    uint32_t srcBinding;
    uint32_t srcArrayElement;
    DescriptorSet dstSet;
    uint32_t dstBinding;
    uint32_t dstArrayElement;
    uint32_t descriptorCount;
};

struct DescriptorBufferInfo {
    Buffer buffer;
    DeviceSize offset;
    DeviceSize range;
};

struct DescriptorImageInfo {
    Sampler sampler;
    ImageView imageView;
    ImageLayout imageLayout;
};

struct DescriptorPoolSize {
    DescriptorType type;
    uint32_t descriptorCount;
};

struct DescriptorPoolCreateInfo {
    StructureType sType;
    const void *pNext;
    DescriptorPoolCreateFlags flags;
    uint32_t maxSets;
    uint32_t poolSizeCount;
    const DescriptorPoolSize *pPoolSizes;
};

struct DescriptorSetAllocateInfo {
    StructureType sType;
    const void *pNext;
    DescriptorPool descriptorPool;
    uint32_t descriptorSetCount;
    const DescriptorSetLayout *pSetLayouts;
};

struct DescriptorSetLayoutBinding {
    uint32_t binding;
    DescriptorType descriptorType;
    uint32_t descriptorCount;
    ShaderStage stageFlags;
    const Sampler *pImmutableSamplers;
};

struct DescriptorSetLayoutCreateInfo {
    StructureType sType;
    const void *pNext;
    DescriptorSetLayoutCreateFlags flags;
    uint32_t bindingCount;
    const DescriptorSetLayoutBinding *pBindings;
};

struct WriteDescriptorSet {
    StructureType sType;
    const void *pNext;
    DescriptorSet dstSet;
    uint32_t dstBinding;
    uint32_t dstArrayElement;
    uint32_t descriptorCount;
    DescriptorType descriptorType;
    const DescriptorImageInfo *pImageInfo;
    const DescriptorBufferInfo *pBufferInfo;
    const BufferView *pTexelBufferView;
};

struct AttachmentDescription {
    AttachmentDescriptionFlags flags;
    Format format;
    SampleCount samples;
    AttachmentLoadOp loadOp;
    AttachmentStoreOp storeOp;
    AttachmentLoadOp stencilLoadOp;
    AttachmentStoreOp stencilStoreOp;
    ImageLayout initialLayout;
    ImageLayout finalLayout;
};

struct AttachmentReference {
    uint32_t attachment;
    ImageLayout layout;
};

struct FramebufferCreateInfo {
    StructureType sType;
    const void *pNext;
    FramebufferCreateFlags flags;
    RenderPass renderPass;
    uint32_t attachmentCount;
    const ImageView *pAttachments;
    uint32_t width;
    uint32_t height;
    uint32_t layers;
};

struct SubpassDescription {
    SubpassDescriptionFlags flags;
    PipelineBindPoint pipelineBindPoint;
    uint32_t inputAttachmentCount;
    const AttachmentReference *pInputAttachments;
    uint32_t colorAttachmentCount;
    const AttachmentReference *pColorAttachments;
    const AttachmentReference *pResolveAttachments;
    const AttachmentReference *pDepthStencilAttachment;
    uint32_t preserveAttachmentCount;
    const uint32_t *pPreserveAttachments;
};

struct SubpassDependency {
    uint32_t srcSubpass;
    uint32_t dstSubpass;
    PipelineStage srcStageMask;
    PipelineStage dstStageMask;
    Access srcAccessMask;
    Access dstAccessMask;
    DependencyFlags dependencyFlags;
};

struct RenderPassCreateInfo {
    StructureType sType;
    const void *pNext;
    RenderPassCreateFlags flags;
    uint32_t attachmentCount;
    const AttachmentDescription *pAttachments;
    uint32_t subpassCount;
    const SubpassDescription *pSubpasses;
    uint32_t dependencyCount;
    const SubpassDependency *pDependencies;
};

struct CommandPoolCreateInfo {
    StructureType sType;
    const void *pNext;
    CommandPoolCreateFlags flags;
    uint32_t queueFamilyIndex;
};

struct CommandBufferAllocateInfo {
    StructureType sType;
    const void *pNext;
    CommandPool commandPool;
    CommandBufferLevel level;
    uint32_t commandBufferCount;
};

struct CommandBufferInheritanceInfo {
    StructureType sType;
    const void *pNext;
    RenderPass renderPass;
    uint32_t subpass;
    Framebuffer framebuffer;
    Bool32 occlusionQueryEnable;
    QueryControlFlags queryFlags;
    QueryPipelineStatisticFlags pipelineStatistics;
};

struct CommandBufferBeginInfo {
    StructureType sType;
    const void *pNext;
    CommandBufferUsage flags;
    const CommandBufferInheritanceInfo *pInheritanceInfo;
};

struct BufferCopy {
    DeviceSize srcOffset;
    DeviceSize dstOffset;
    DeviceSize size;
};

struct ImageSubresourceLayers {
    ImageAspect aspectMask;
    uint32_t mipLevel;
    uint32_t baseArrayLayer;
    uint32_t layerCount;
};

struct BufferImageCopy {
    DeviceSize bufferOffset;
    uint32_t bufferRowLength;
    uint32_t bufferImageHeight;
    ImageSubresourceLayers imageSubresource;
    Offset3D imageOffset;
    Extent3D imageExtent;
};

union ClearColorValue {
    // NOLINTNEXTLINE
    float float32 [4];
    // NOLINTNEXTLINE
    int32_t int32 [4];
    // NOLINTNEXTLINE
    uint32_t uint32 [4];
};

struct ClearDepthStencilValue {
    float depth;
    uint32_t stencil;
};

union ClearValue {
    ClearColorValue color;
    ClearDepthStencilValue depthStencil;
};

struct ClearAttachment {
    ImageAspect aspectMask;
    uint32_t colorAttachment;
    ClearValue clearValue;
};

struct ClearRect {
    Rect2D rect;
    uint32_t baseArrayLayer;
    uint32_t layerCount;
};

struct ImageBlit {
    ImageSubresourceLayers srcSubresource;
    // NOLINTNEXTLINE
    Offset3D srcOffsets [2];
    ImageSubresourceLayers dstSubresource;
    // NOLINTNEXTLINE
    Offset3D dstOffsets [2];
};

struct ImageCopy {
    ImageSubresourceLayers srcSubresource;
    Offset3D srcOffset;
    ImageSubresourceLayers dstSubresource;
    Offset3D dstOffset;
    Extent3D extent;
};

struct ImageResolve {
    ImageSubresourceLayers srcSubresource;
    Offset3D srcOffset;
    ImageSubresourceLayers dstSubresource;
    Offset3D dstOffset;
    Extent3D extent;
};

struct RenderPassBeginInfo {
    StructureType sType;
    const void *pNext;
    RenderPass renderPass;
    Framebuffer framebuffer;
    Rect2D renderArea;
    uint32_t clearValueCount;
    const ClearValue *pClearValues;
};

struct PhysicalDeviceSubgroupProperties {
    StructureType sType;
    void *pNext;
    uint32_t subgroupSize;
    ShaderStage supportedStages;
    SubgroupFeature supportedOperations;
    Bool32 quadOperationsInAllStages;
};

struct BindBufferMemoryInfo {
    StructureType sType;
    const void *pNext;
    Buffer buffer;
    DeviceMemory memory;
    DeviceSize memoryOffset;
};

struct BindImageMemoryInfo {
    StructureType sType;
    const void *pNext;
    Image image;
    DeviceMemory memory;
    DeviceSize memoryOffset;
};

struct PhysicalDevice16BitStorageFeatures {
    StructureType sType;
    void *pNext;
    Bool32 storageBuffer16BitAccess;
    Bool32 uniformAndStorageBuffer16BitAccess;
    Bool32 storagePushConstant16;
    Bool32 storageInputOutput16;
};

struct MemoryDedicatedRequirements {
    StructureType sType;
    void *pNext;
    Bool32 prefersDedicatedAllocation;
    Bool32 requiresDedicatedAllocation;
};

struct MemoryDedicatedAllocateInfo {
    StructureType sType;
    const void *pNext;
    Image image;
    Buffer buffer;
};

struct MemoryAllocateFlagsInfo {
    StructureType sType;
    const void *pNext;
    MemoryAllocateFlags flags;
    uint32_t deviceMask;
};

struct DeviceGroupRenderPassBeginInfo {
    StructureType sType;
    const void *pNext;
    uint32_t deviceMask;
    uint32_t deviceRenderAreaCount;
    const Rect2D *pDeviceRenderAreas;
};

struct DeviceGroupCommandBufferBeginInfo {
    StructureType sType;
    const void *pNext;
    uint32_t deviceMask;
};

struct DeviceGroupSubmitInfo {
    StructureType sType;
    const void *pNext;
    uint32_t waitSemaphoreCount;
    const uint32_t *pWaitSemaphoreDeviceIndices;
    uint32_t commandBufferCount;
    const uint32_t *pCommandBufferDeviceMasks;
    uint32_t signalSemaphoreCount;
    const uint32_t *pSignalSemaphoreDeviceIndices;
};

struct DeviceGroupBindSparseInfo {
    StructureType sType;
    const void *pNext;
    uint32_t resourceDeviceIndex;
    uint32_t memoryDeviceIndex;
};

struct BindBufferMemoryDeviceGroupInfo {
    StructureType sType;
    const void *pNext;
    uint32_t deviceIndexCount;
    const uint32_t *pDeviceIndices;
};

struct BindImageMemoryDeviceGroupInfo {
    StructureType sType;
    const void *pNext;
    uint32_t deviceIndexCount;
    const uint32_t *pDeviceIndices;
    uint32_t splitInstanceBindRegionCount;
    const Rect2D *pSplitInstanceBindRegions;
};

struct PhysicalDeviceGroupProperties {
    StructureType sType;
    void *pNext;
    uint32_t physicalDeviceCount;
    // NOLINTNEXTLINE
    PhysicalDevice physicalDevices [VK_MAX_DEVICE_GROUP_SIZE ];
    Bool32 subsetAllocation;
};

struct DeviceGroupDeviceCreateInfo {
    StructureType sType;
    const void *pNext;
    uint32_t physicalDeviceCount;
    const PhysicalDevice *pPhysicalDevices;
};

struct BufferMemoryRequirementsInfo2 {
    StructureType sType;
    const void *pNext;
    Buffer buffer;
};

struct ImageMemoryRequirementsInfo2 {
    StructureType sType;
    const void *pNext;
    Image image;
};

struct ImageSparseMemoryRequirementsInfo2 {
    StructureType sType;
    const void *pNext;
    Image image;
};

struct MemoryRequirements2 {
    StructureType sType;
    void *pNext;
    MemoryRequirements memoryRequirements;
};

struct SparseImageMemoryRequirements2 {
    StructureType sType;
    void *pNext;
    SparseImageMemoryRequirements memoryRequirements;
};

struct PhysicalDeviceFeatures2 {
    StructureType sType;
    void *pNext;
    PhysicalDeviceFeatures features;
};

struct PhysicalDeviceProperties2 {
    StructureType sType;
    void *pNext;
    PhysicalDeviceProperties properties;
};

struct FormatProperties2 {
    StructureType sType;
    void *pNext;
    FormatProperties formatProperties;
};

struct ImageFormatProperties2 {
    StructureType sType;
    void *pNext;
    ImageFormatProperties imageFormatProperties;
};

struct PhysicalDeviceImageFormatInfo2 {
    StructureType sType;
    const void *pNext;
    Format format;
    ImageType type;
    ImageTiling tiling;
    ImageUsage usage;
    ImageCreateFlags flags;
};

struct QueueFamilyProperties2 {
    StructureType sType;
    void *pNext;
    QueueFamilyProperties queueFamilyProperties;
};

struct PhysicalDeviceMemoryProperties2 {
    StructureType sType;
    void *pNext;
    PhysicalDeviceMemoryProperties memoryProperties;
};

struct SparseImageFormatProperties2 {
    StructureType sType;
    void *pNext;
    SparseImageFormatProperties properties;
};

struct PhysicalDeviceSparseImageFormatInfo2 {
    StructureType sType;
    const void *pNext;
    Format format;
    ImageType type;
    SampleCount samples;
    ImageUsage usage;
    ImageTiling tiling;
};

struct PhysicalDevicePointClippingProperties {
    StructureType sType;
    void *pNext;
    PointClippingBehavior pointClippingBehavior;
};

struct InputAttachmentAspectReference {
    uint32_t subpass;
    uint32_t inputAttachmentIndex;
    ImageAspect aspectMask;
};

struct RenderPassInputAttachmentAspectCreateInfo {
    StructureType sType;
    const void *pNext;
    uint32_t aspectReferenceCount;
    const InputAttachmentAspectReference *pAspectReferences;
};

struct ImageViewUsageCreateInfo {
    StructureType sType;
    const void *pNext;
    ImageUsage usage;
};

struct PipelineTessellationDomainOriginStateCreateInfo {
    StructureType sType;
    const void *pNext;
    TessellationDomainOrigin domainOrigin;
};

struct RenderPassMultiviewCreateInfo {
    StructureType sType;
    const void *pNext;
    uint32_t subpassCount;
    const uint32_t *pViewMasks;
    uint32_t dependencyCount;
    const int32_t *pViewOffsets;
    uint32_t correlationMaskCount;
    const uint32_t *pCorrelationMasks;
};

struct PhysicalDeviceMultiviewFeatures {
    StructureType sType;
    void *pNext;
    Bool32 multiview;
    Bool32 multiviewGeometryShader;
    Bool32 multiviewTessellationShader;
};

struct PhysicalDeviceMultiviewProperties {
    StructureType sType;
    void *pNext;
    uint32_t maxMultiviewViewCount;
    uint32_t maxMultiviewInstanceIndex;
};

struct PhysicalDeviceVariablePointerFeatures {
};

struct PhysicalDeviceVariablePointersFeatures {
    StructureType sType;
    void *pNext;
    Bool32 variablePointersStorageBuffer;
    Bool32 variablePointers;
};

struct PhysicalDeviceProtectedMemoryFeatures {
    StructureType sType;
    void *pNext;
    Bool32 protectedMemory;
};

struct PhysicalDeviceProtectedMemoryProperties {
    StructureType sType;
    void *pNext;
    Bool32 protectedNoFault;
};

struct DeviceQueueInfo2 {
    StructureType sType;
    const void *pNext;
    DeviceQueueCreateFlags flags;
    uint32_t queueFamilyIndex;
    uint32_t queueIndex;
};

struct ProtectedSubmitInfo {
    StructureType sType;
    const void *pNext;
    Bool32 protectedSubmit;
};

struct SamplerYcbcrConversionCreateInfo {
    StructureType sType;
    const void *pNext;
    Format format;
    SamplerYcbcrModelConversion ycbcrModel;
    SamplerYcbcrRange ycbcrRange;
    ComponentMapping components;
    ChromaLocation xChromaOffset;
    ChromaLocation yChromaOffset;
    Filter chromaFilter;
    Bool32 forceExplicitReconstruction;
};

struct SamplerYcbcrConversionInfo {
    StructureType sType;
    const void *pNext;
    SamplerYcbcrConversion conversion;
};

struct BindImagePlaneMemoryInfo {
    StructureType sType;
    const void *pNext;
    ImageAspect planeAspect;
};

struct ImagePlaneMemoryRequirementsInfo {
    StructureType sType;
    const void *pNext;
    ImageAspect planeAspect;
};

struct PhysicalDeviceSamplerYcbcrConversionFeatures {
    StructureType sType;
    void *pNext;
    Bool32 samplerYcbcrConversion;
};

struct SamplerYcbcrConversionImageFormatProperties {
    StructureType sType;
    void *pNext;
    uint32_t combinedImageSamplerDescriptorCount;
};

struct DescriptorUpdateTemplateEntry {
    uint32_t dstBinding;
    uint32_t dstArrayElement;
    uint32_t descriptorCount;
    DescriptorType descriptorType;
    size_t offset;
    size_t stride;
};

struct DescriptorUpdateTemplateCreateInfo {
    StructureType sType;
    const void *pNext;
    DescriptorUpdateTemplateCreateFlags flags;
    uint32_t descriptorUpdateEntryCount;
    const DescriptorUpdateTemplateEntry *pDescriptorUpdateEntries;
    DescriptorUpdateTemplateType templateType;
    DescriptorSetLayout descriptorSetLayout;
    PipelineBindPoint pipelineBindPoint;
    PipelineLayout pipelineLayout;
    uint32_t set;
};

struct ExternalMemoryProperties {
    ExternalMemoryFeature externalMemoryFeatures;
    ExternalMemoryHandleTypeFlags exportFromImportedHandleTypes;
    ExternalMemoryHandleTypeFlags compatibleHandleTypes;
};

struct PhysicalDeviceExternalImageFormatInfo {
    StructureType sType;
    const void *pNext;
    ExternalMemoryHandleTypeFlags handleType;
};

struct ExternalImageFormatProperties {
    StructureType sType;
    void *pNext;
    ExternalMemoryProperties externalMemoryProperties;
};

struct PhysicalDeviceExternalBufferInfo {
    StructureType sType;
    const void *pNext;
    BufferCreateFlags flags;
    BufferUsage usage;
    ExternalMemoryHandleTypeFlags handleType;
};

struct ExternalBufferProperties {
    StructureType sType;
    void *pNext;
    ExternalMemoryProperties externalMemoryProperties;
};

struct PhysicalDeviceIDProperties {
    StructureType sType;
    void *pNext;
    // NOLINTNEXTLINE
    uint8_t deviceUUID [VK_UUID_SIZE ];
    // NOLINTNEXTLINE
    uint8_t driverUUID [VK_UUID_SIZE ];
    // NOLINTNEXTLINE
    uint8_t deviceLUID [VK_LUID_SIZE ];
    uint32_t deviceNodeMask;
    Bool32 deviceLUIDValid;
};

struct ExternalMemoryImageCreateInfo {
    StructureType sType;
    const void *pNext;
    ExternalMemoryHandleTypeFlags handleTypes;
};

struct ExternalMemoryBufferCreateInfo {
    StructureType sType;
    const void *pNext;
    ExternalMemoryHandleTypeFlags handleTypes;
};

struct ExportMemoryAllocateInfo {
    StructureType sType;
    const void *pNext;
    ExternalMemoryHandleTypeFlags handleTypes;
};

struct PhysicalDeviceExternalFenceInfo {
    StructureType sType;
    const void *pNext;
    ExternalFenceHandleTypeFlags handleType;
};

struct ExternalFenceProperties {
    StructureType sType;
    void *pNext;
    ExternalFenceHandleTypeFlags exportFromImportedHandleTypes;
    ExternalFenceHandleTypeFlags compatibleHandleTypes;
    ExternalFenceFeature externalFenceFeatures;
};

struct ExportFenceCreateInfo {
    StructureType sType;
    const void *pNext;
    ExternalFenceHandleTypeFlags handleTypes;
};

struct ExportSemaphoreCreateInfo {
    StructureType sType;
    const void *pNext;
    ExternalSemaphoreHandleTypeFlags handleTypes;
};

struct PhysicalDeviceExternalSemaphoreInfo {
    StructureType sType;
    const void *pNext;
    ExternalSemaphoreHandleTypeFlags handleType;
};

struct ExternalSemaphoreProperties {
    StructureType sType;
    void *pNext;
    ExternalSemaphoreHandleTypeFlags exportFromImportedHandleTypes;
    ExternalSemaphoreHandleTypeFlags compatibleHandleTypes;
    ExternalSemaphoreFeature externalSemaphoreFeatures;
};

struct PhysicalDeviceMaintenance3Properties {
    StructureType sType;
    void *pNext;
    uint32_t maxPerSetDescriptors;
    DeviceSize maxMemoryAllocationSize;
};

struct DescriptorSetLayoutSupport {
    StructureType sType;
    void *pNext;
    Bool32 supported;
};

struct PhysicalDeviceShaderDrawParameterFeatures {
};

struct PhysicalDeviceShaderDrawParametersFeatures {
    StructureType sType;
    void *pNext;
    Bool32 shaderDrawParameters;
};

struct PhysicalDeviceVulkan11Features {
    StructureType sType;
    void *pNext;
    Bool32 storageBuffer16BitAccess;
    Bool32 uniformAndStorageBuffer16BitAccess;
    Bool32 storagePushConstant16;
    Bool32 storageInputOutput16;
    Bool32 multiview;
    Bool32 multiviewGeometryShader;
    Bool32 multiviewTessellationShader;
    Bool32 variablePointersStorageBuffer;
    Bool32 variablePointers;
    Bool32 protectedMemory;
    Bool32 samplerYcbcrConversion;
    Bool32 shaderDrawParameters;
};

struct PhysicalDeviceVulkan11Properties {
    StructureType sType;
    void *pNext;
    // NOLINTNEXTLINE
    uint8_t deviceUUID [VK_UUID_SIZE ];
    // NOLINTNEXTLINE
    uint8_t driverUUID [VK_UUID_SIZE ];
    // NOLINTNEXTLINE
    uint8_t deviceLUID [VK_LUID_SIZE ];
    uint32_t deviceNodeMask;
    Bool32 deviceLUIDValid;
    uint32_t subgroupSize;
    ShaderStage subgroupSupportedStages;
    SubgroupFeature subgroupSupportedOperations;
    Bool32 subgroupQuadOperationsInAllStages;
    PointClippingBehavior pointClippingBehavior;
    uint32_t maxMultiviewViewCount;
    uint32_t maxMultiviewInstanceIndex;
    Bool32 protectedNoFault;
    uint32_t maxPerSetDescriptors;
    DeviceSize maxMemoryAllocationSize;
};

struct PhysicalDeviceVulkan12Features {
    StructureType sType;
    void *pNext;
    Bool32 samplerMirrorClampToEdge;
    Bool32 drawIndirectCount;
    Bool32 storageBuffer8BitAccess;
    Bool32 uniformAndStorageBuffer8BitAccess;
    Bool32 storagePushConstant8;
    Bool32 shaderBufferInt64Atomics;
    Bool32 shaderSharedInt64Atomics;
    Bool32 shaderFloat16;
    Bool32 shaderInt8;
    Bool32 descriptorIndexing;
    Bool32 shaderInputAttachmentArrayDynamicIndexing;
    Bool32 shaderUniformTexelBufferArrayDynamicIndexing;
    Bool32 shaderStorageTexelBufferArrayDynamicIndexing;
    Bool32 shaderUniformBufferArrayNonUniformIndexing;
    Bool32 shaderSampledImageArrayNonUniformIndexing;
    Bool32 shaderStorageBufferArrayNonUniformIndexing;
    Bool32 shaderStorageImageArrayNonUniformIndexing;
    Bool32 shaderInputAttachmentArrayNonUniformIndexing;
    Bool32 shaderUniformTexelBufferArrayNonUniformIndexing;
    Bool32 shaderStorageTexelBufferArrayNonUniformIndexing;
    Bool32 descriptorBindingUniformBufferUpdateAfterBind;
    Bool32 descriptorBindingSampledImageUpdateAfterBind;
    Bool32 descriptorBindingStorageImageUpdateAfterBind;
    Bool32 descriptorBindingStorageBufferUpdateAfterBind;
    Bool32 descriptorBindingUniformTexelBufferUpdateAfterBind;
    Bool32 descriptorBindingStorageTexelBufferUpdateAfterBind;
    Bool32 descriptorBindingUpdateUnusedWhilePending;
    Bool32 descriptorBindingPartiallyBound;
    Bool32 descriptorBindingVariableDescriptorCount;
    Bool32 runtimeDescriptorArray;
    Bool32 samplerFilterMinmax;
    Bool32 scalarBlockLayout;
    Bool32 imagelessFramebuffer;
    Bool32 uniformBufferStandardLayout;
    Bool32 shaderSubgroupExtendedTypes;
    Bool32 separateDepthStencilLayouts;
    Bool32 hostQueryReset;
    Bool32 timelineSemaphore;
    Bool32 bufferDeviceAddress;
    Bool32 bufferDeviceAddressCaptureReplay;
    Bool32 bufferDeviceAddressMultiDevice;
    Bool32 vulkanMemoryModel;
    Bool32 vulkanMemoryModelDeviceScope;
    Bool32 vulkanMemoryModelAvailabilityVisibilityChains;
    Bool32 shaderOutputViewportIndex;
    Bool32 shaderOutputLayer;
    Bool32 subgroupBroadcastDynamicId;
};

struct ConformanceVersion {
    uint8_t major;
    uint8_t minor;
    uint8_t subminor;
    uint8_t patch;
};

struct PhysicalDeviceVulkan12Properties {
    StructureType sType;
    void *pNext;
    DriverId driverID;
    // NOLINTNEXTLINE
    char driverName [VK_MAX_DRIVER_NAME_SIZE ];
    // NOLINTNEXTLINE
    char driverInfo [VK_MAX_DRIVER_INFO_SIZE ];
    ConformanceVersion conformanceVersion;
    ShaderFloatControlsIndependence denormBehaviorIndependence;
    ShaderFloatControlsIndependence roundingModeIndependence;
    Bool32 shaderSignedZeroInfNanPreserveFloat16;
    Bool32 shaderSignedZeroInfNanPreserveFloat32;
    Bool32 shaderSignedZeroInfNanPreserveFloat64;
    Bool32 shaderDenormPreserveFloat16;
    Bool32 shaderDenormPreserveFloat32;
    Bool32 shaderDenormPreserveFloat64;
    Bool32 shaderDenormFlushToZeroFloat16;
    Bool32 shaderDenormFlushToZeroFloat32;
    Bool32 shaderDenormFlushToZeroFloat64;
    Bool32 shaderRoundingModeRTEFloat16;
    Bool32 shaderRoundingModeRTEFloat32;
    Bool32 shaderRoundingModeRTEFloat64;
    Bool32 shaderRoundingModeRTZFloat16;
    Bool32 shaderRoundingModeRTZFloat32;
    Bool32 shaderRoundingModeRTZFloat64;
    uint32_t maxUpdateAfterBindDescriptorsInAllPools;
    Bool32 shaderUniformBufferArrayNonUniformIndexingNative;
    Bool32 shaderSampledImageArrayNonUniformIndexingNative;
    Bool32 shaderStorageBufferArrayNonUniformIndexingNative;
    Bool32 shaderStorageImageArrayNonUniformIndexingNative;
    Bool32 shaderInputAttachmentArrayNonUniformIndexingNative;
    Bool32 robustBufferAccessUpdateAfterBind;
    Bool32 quadDivergentImplicitLod;
    uint32_t maxPerStageDescriptorUpdateAfterBindSamplers;
    uint32_t maxPerStageDescriptorUpdateAfterBindUniformBuffers;
    uint32_t maxPerStageDescriptorUpdateAfterBindStorageBuffers;
    uint32_t maxPerStageDescriptorUpdateAfterBindSampledImages;
    uint32_t maxPerStageDescriptorUpdateAfterBindStorageImages;
    uint32_t maxPerStageDescriptorUpdateAfterBindInputAttachments;
    uint32_t maxPerStageUpdateAfterBindResources;
    uint32_t maxDescriptorSetUpdateAfterBindSamplers;
    uint32_t maxDescriptorSetUpdateAfterBindUniformBuffers;
    uint32_t maxDescriptorSetUpdateAfterBindUniformBuffersDynamic;
    uint32_t maxDescriptorSetUpdateAfterBindStorageBuffers;
    uint32_t maxDescriptorSetUpdateAfterBindStorageBuffersDynamic;
    uint32_t maxDescriptorSetUpdateAfterBindSampledImages;
    uint32_t maxDescriptorSetUpdateAfterBindStorageImages;
    uint32_t maxDescriptorSetUpdateAfterBindInputAttachments;
    ResolveMode supportedDepthResolveModes;
    ResolveMode supportedStencilResolveModes;
    Bool32 independentResolveNone;
    Bool32 independentResolve;
    Bool32 filterMinmaxSingleComponentFormats;
    Bool32 filterMinmaxImageComponentMapping;
    uint64_t maxTimelineSemaphoreValueDifference;
    SampleCount framebufferIntegerColorSampleCounts;
};

struct ImageFormatListCreateInfo {
    StructureType sType;
    const void *pNext;
    uint32_t viewFormatCount;
    const Format *pViewFormats;
};

struct AttachmentDescription2 {
    StructureType sType;
    const void *pNext;
    AttachmentDescriptionFlags flags;
    Format format;
    SampleCount samples;
    AttachmentLoadOp loadOp;
    AttachmentStoreOp storeOp;
    AttachmentLoadOp stencilLoadOp;
    AttachmentStoreOp stencilStoreOp;
    ImageLayout initialLayout;
    ImageLayout finalLayout;
};

struct AttachmentReference2 {
    StructureType sType;
    const void *pNext;
    uint32_t attachment;
    ImageLayout layout;
    ImageAspect aspectMask;
};

struct SubpassDescription2 {
    StructureType sType;
    const void *pNext;
    SubpassDescriptionFlags flags;
    PipelineBindPoint pipelineBindPoint;
    uint32_t viewMask;
    uint32_t inputAttachmentCount;
    const AttachmentReference2 *pInputAttachments;
    uint32_t colorAttachmentCount;
    const AttachmentReference2 *pColorAttachments;
    const AttachmentReference2 *pResolveAttachments;
    const AttachmentReference2 *pDepthStencilAttachment;
    uint32_t preserveAttachmentCount;
    const uint32_t *pPreserveAttachments;
};

struct SubpassDependency2 {
    StructureType sType;
    const void *pNext;
    uint32_t srcSubpass;
    uint32_t dstSubpass;
    PipelineStage srcStageMask;
    PipelineStage dstStageMask;
    Access srcAccessMask;
    Access dstAccessMask;
    DependencyFlags dependencyFlags;
    int32_t viewOffset;
};

struct RenderPassCreateInfo2 {
    StructureType sType;
    const void *pNext;
    RenderPassCreateFlags flags;
    uint32_t attachmentCount;
    const AttachmentDescription2 *pAttachments;
    uint32_t subpassCount;
    const SubpassDescription2 *pSubpasses;
    uint32_t dependencyCount;
    const SubpassDependency2 *pDependencies;
    uint32_t correlatedViewMaskCount;
    const uint32_t *pCorrelatedViewMasks;
};

struct SubpassBeginInfo {
    StructureType sType;
    const void *pNext;
    SubpassContents contents;
};

struct SubpassEndInfo {
    StructureType sType;
    const void *pNext;
};

struct PhysicalDevice8BitStorageFeatures {
    StructureType sType;
    void *pNext;
    Bool32 storageBuffer8BitAccess;
    Bool32 uniformAndStorageBuffer8BitAccess;
    Bool32 storagePushConstant8;
};

struct PhysicalDeviceDriverProperties {
    StructureType sType;
    void *pNext;
    DriverId driverID;
    // NOLINTNEXTLINE
    char driverName [VK_MAX_DRIVER_NAME_SIZE ];
    // NOLINTNEXTLINE
    char driverInfo [VK_MAX_DRIVER_INFO_SIZE ];
    ConformanceVersion conformanceVersion;
};

struct PhysicalDeviceShaderAtomicInt64Features {
    StructureType sType;
    void *pNext;
    Bool32 shaderBufferInt64Atomics;
    Bool32 shaderSharedInt64Atomics;
};

struct PhysicalDeviceShaderFloat16Int8Features {
    StructureType sType;
    void *pNext;
    Bool32 shaderFloat16;
    Bool32 shaderInt8;
};

struct PhysicalDeviceFloatControlsProperties {
    StructureType sType;
    void *pNext;
    ShaderFloatControlsIndependence denormBehaviorIndependence;
    ShaderFloatControlsIndependence roundingModeIndependence;
    Bool32 shaderSignedZeroInfNanPreserveFloat16;
    Bool32 shaderSignedZeroInfNanPreserveFloat32;
    Bool32 shaderSignedZeroInfNanPreserveFloat64;
    Bool32 shaderDenormPreserveFloat16;
    Bool32 shaderDenormPreserveFloat32;
    Bool32 shaderDenormPreserveFloat64;
    Bool32 shaderDenormFlushToZeroFloat16;
    Bool32 shaderDenormFlushToZeroFloat32;
    Bool32 shaderDenormFlushToZeroFloat64;
    Bool32 shaderRoundingModeRTEFloat16;
    Bool32 shaderRoundingModeRTEFloat32;
    Bool32 shaderRoundingModeRTEFloat64;
    Bool32 shaderRoundingModeRTZFloat16;
    Bool32 shaderRoundingModeRTZFloat32;
    Bool32 shaderRoundingModeRTZFloat64;
};

struct DescriptorSetLayoutBindingFlagsCreateInfo {
    StructureType sType;
    const void *pNext;
    uint32_t bindingCount;
    const DescriptorBindingFlags *pBindingFlags;
};

struct PhysicalDeviceDescriptorIndexingFeatures {
    StructureType sType;
    void *pNext;
    Bool32 shaderInputAttachmentArrayDynamicIndexing;
    Bool32 shaderUniformTexelBufferArrayDynamicIndexing;
    Bool32 shaderStorageTexelBufferArrayDynamicIndexing;
    Bool32 shaderUniformBufferArrayNonUniformIndexing;
    Bool32 shaderSampledImageArrayNonUniformIndexing;
    Bool32 shaderStorageBufferArrayNonUniformIndexing;
    Bool32 shaderStorageImageArrayNonUniformIndexing;
    Bool32 shaderInputAttachmentArrayNonUniformIndexing;
    Bool32 shaderUniformTexelBufferArrayNonUniformIndexing;
    Bool32 shaderStorageTexelBufferArrayNonUniformIndexing;
    Bool32 descriptorBindingUniformBufferUpdateAfterBind;
    Bool32 descriptorBindingSampledImageUpdateAfterBind;
    Bool32 descriptorBindingStorageImageUpdateAfterBind;
    Bool32 descriptorBindingStorageBufferUpdateAfterBind;
    Bool32 descriptorBindingUniformTexelBufferUpdateAfterBind;
    Bool32 descriptorBindingStorageTexelBufferUpdateAfterBind;
    Bool32 descriptorBindingUpdateUnusedWhilePending;
    Bool32 descriptorBindingPartiallyBound;
    Bool32 descriptorBindingVariableDescriptorCount;
    Bool32 runtimeDescriptorArray;
};

struct PhysicalDeviceDescriptorIndexingProperties {
    StructureType sType;
    void *pNext;
    uint32_t maxUpdateAfterBindDescriptorsInAllPools;
    Bool32 shaderUniformBufferArrayNonUniformIndexingNative;
    Bool32 shaderSampledImageArrayNonUniformIndexingNative;
    Bool32 shaderStorageBufferArrayNonUniformIndexingNative;
    Bool32 shaderStorageImageArrayNonUniformIndexingNative;
    Bool32 shaderInputAttachmentArrayNonUniformIndexingNative;
    Bool32 robustBufferAccessUpdateAfterBind;
    Bool32 quadDivergentImplicitLod;
    uint32_t maxPerStageDescriptorUpdateAfterBindSamplers;
    uint32_t maxPerStageDescriptorUpdateAfterBindUniformBuffers;
    uint32_t maxPerStageDescriptorUpdateAfterBindStorageBuffers;
    uint32_t maxPerStageDescriptorUpdateAfterBindSampledImages;
    uint32_t maxPerStageDescriptorUpdateAfterBindStorageImages;
    uint32_t maxPerStageDescriptorUpdateAfterBindInputAttachments;
    uint32_t maxPerStageUpdateAfterBindResources;
    uint32_t maxDescriptorSetUpdateAfterBindSamplers;
    uint32_t maxDescriptorSetUpdateAfterBindUniformBuffers;
    uint32_t maxDescriptorSetUpdateAfterBindUniformBuffersDynamic;
    uint32_t maxDescriptorSetUpdateAfterBindStorageBuffers;
    uint32_t maxDescriptorSetUpdateAfterBindStorageBuffersDynamic;
    uint32_t maxDescriptorSetUpdateAfterBindSampledImages;
    uint32_t maxDescriptorSetUpdateAfterBindStorageImages;
    uint32_t maxDescriptorSetUpdateAfterBindInputAttachments;
};

struct DescriptorSetVariableDescriptorCountAllocateInfo {
    StructureType sType;
    const void *pNext;
    uint32_t descriptorSetCount;
    const uint32_t *pDescriptorCounts;
};

struct DescriptorSetVariableDescriptorCountLayoutSupport {
    StructureType sType;
    void *pNext;
    uint32_t maxVariableDescriptorCount;
};

struct SubpassDescriptionDepthStencilResolve {
    StructureType sType;
    const void *pNext;
    ResolveMode depthResolveMode;
    ResolveMode stencilResolveMode;
    const AttachmentReference2 *pDepthStencilResolveAttachment;
};

struct PhysicalDeviceDepthStencilResolveProperties {
    StructureType sType;
    void *pNext;
    ResolveMode supportedDepthResolveModes;
    ResolveMode supportedStencilResolveModes;
    Bool32 independentResolveNone;
    Bool32 independentResolve;
};

struct PhysicalDeviceScalarBlockLayoutFeatures {
    StructureType sType;
    void *pNext;
    Bool32 scalarBlockLayout;
};

struct ImageStencilUsageCreateInfo {
    StructureType sType;
    const void *pNext;
    ImageUsage stencilUsage;
};

struct SamplerReductionModeCreateInfo {
    StructureType sType;
    const void *pNext;
    SamplerReductionMode reductionMode;
};

struct PhysicalDeviceSamplerFilterMinmaxProperties {
    StructureType sType;
    void *pNext;
    Bool32 filterMinmaxSingleComponentFormats;
    Bool32 filterMinmaxImageComponentMapping;
};

struct PhysicalDeviceVulkanMemoryModelFeatures {
    StructureType sType;
    void *pNext;
    Bool32 vulkanMemoryModel;
    Bool32 vulkanMemoryModelDeviceScope;
    Bool32 vulkanMemoryModelAvailabilityVisibilityChains;
};

struct PhysicalDeviceImagelessFramebufferFeatures {
    StructureType sType;
    void *pNext;
    Bool32 imagelessFramebuffer;
};

struct FramebufferAttachmentImageInfo {
    StructureType sType;
    const void *pNext;
    ImageCreateFlags flags;
    ImageUsage usage;
    uint32_t width;
    uint32_t height;
    uint32_t layerCount;
    uint32_t viewFormatCount;
    const Format *pViewFormats;
};

struct FramebufferAttachmentsCreateInfo {
    StructureType sType;
    const void *pNext;
    uint32_t attachmentImageInfoCount;
    const FramebufferAttachmentImageInfo *pAttachmentImageInfos;
};

struct RenderPassAttachmentBeginInfo {
    StructureType sType;
    const void *pNext;
    uint32_t attachmentCount;
    const ImageView *pAttachments;
};

struct PhysicalDeviceUniformBufferStandardLayoutFeatures {
    StructureType sType;
    void *pNext;
    Bool32 uniformBufferStandardLayout;
};

struct PhysicalDeviceShaderSubgroupExtendedTypesFeatures {
    StructureType sType;
    void *pNext;
    Bool32 shaderSubgroupExtendedTypes;
};

struct PhysicalDeviceSeparateDepthStencilLayoutsFeatures {
    StructureType sType;
    void *pNext;
    Bool32 separateDepthStencilLayouts;
};

struct AttachmentReferenceStencilLayout {
    StructureType sType;
    void *pNext;
    ImageLayout stencilLayout;
};

struct AttachmentDescriptionStencilLayout {
    StructureType sType;
    void *pNext;
    ImageLayout stencilInitialLayout;
    ImageLayout stencilFinalLayout;
};

struct PhysicalDeviceHostQueryResetFeatures {
    StructureType sType;
    void *pNext;
    Bool32 hostQueryReset;
};

struct PhysicalDeviceTimelineSemaphoreFeatures {
    StructureType sType;
    void *pNext;
    Bool32 timelineSemaphore;
};

struct PhysicalDeviceTimelineSemaphoreProperties {
    StructureType sType;
    void *pNext;
    uint64_t maxTimelineSemaphoreValueDifference;
};

struct SemaphoreTypeCreateInfo {
    StructureType sType;
    const void *pNext;
    SemaphoreType semaphoreType;
    uint64_t initialValue;
};

struct TimelineSemaphoreSubmitInfo {
    StructureType sType;
    const void *pNext;
    uint32_t waitSemaphoreValueCount;
    const uint64_t *pWaitSemaphoreValues;
    uint32_t signalSemaphoreValueCount;
    const uint64_t *pSignalSemaphoreValues;
};

struct SemaphoreWaitInfo {
    StructureType sType;
    const void *pNext;
    SemaphoreWaitFlags flags;
    uint32_t semaphoreCount;
    const Semaphore *pSemaphores;
    const uint64_t *pValues;
};

struct SemaphoreSignalInfo {
    StructureType sType;
    const void *pNext;
    Semaphore semaphore;
    uint64_t value;
};

struct PhysicalDeviceBufferDeviceAddressFeatures {
    StructureType sType;
    void *pNext;
    Bool32 bufferDeviceAddress;
    Bool32 bufferDeviceAddressCaptureReplay;
    Bool32 bufferDeviceAddressMultiDevice;
};

struct BufferDeviceAddressInfo {
    StructureType sType;
    const void *pNext;
    Buffer buffer;
};

struct BufferOpaqueCaptureAddressCreateInfo {
    StructureType sType;
    const void *pNext;
    uint64_t opaqueCaptureAddress;
};

struct MemoryOpaqueCaptureAddressAllocateInfo {
    StructureType sType;
    const void *pNext;
    uint64_t opaqueCaptureAddress;
};

struct DeviceMemoryOpaqueCaptureAddressInfo {
    StructureType sType;
    const void *pNext;
    DeviceMemory memory;
};

struct PhysicalDeviceShaderAtomicFloat2FeaturesEXT {
    StructureType sType;
    void *pNext;
    Bool32 shaderBufferFloat16Atomics;
    Bool32 shaderBufferFloat16AtomicAdd;
    Bool32 shaderBufferFloat16AtomicMinMax;
    Bool32 shaderBufferFloat32AtomicMinMax;
    Bool32 shaderBufferFloat64AtomicMinMax;
    Bool32 shaderSharedFloat16Atomics;
    Bool32 shaderSharedFloat16AtomicAdd;
    Bool32 shaderSharedFloat16AtomicMinMax;
    Bool32 shaderSharedFloat32AtomicMinMax;
    Bool32 shaderSharedFloat64AtomicMinMax;
    Bool32 shaderImageFloat32AtomicMinMax;
    Bool32 sparseImageFloat32AtomicMinMax;
};

struct RenderingAttachmentInfoKHR {
    StructureType sType;
    const void *pNext;
    ImageView imageView;
    ImageLayout imageLayout;
    ResolveMode resolveMode;
    ImageView resolveImageView;
    ImageLayout resolveImageLayout;
    AttachmentLoadOp loadOp;
    AttachmentStoreOp storeOp;
    ClearValue clearValue;
};

struct RenderingInfoKHR {
    StructureType sType;
    const void *pNext;
    RenderingFlagsKHR flags;
    Rect2D renderArea;
    uint32_t layerCount;
    uint32_t viewMask;
    uint32_t colorAttachmentCount;
    const RenderingAttachmentInfoKHR *pColorAttachments;
    const RenderingAttachmentInfoKHR *pDepthAttachment;
    const RenderingAttachmentInfoKHR *pStencilAttachment;
};

struct PipelineRenderingCreateInfoKHR {
    StructureType sType;
    const void *pNext;
    uint32_t viewMask;
    uint32_t colorAttachmentCount;
    const Format *pColorAttachmentFormats;
    Format depthAttachmentFormat;
    Format stencilAttachmentFormat;
};

struct PhysicalDeviceDynamicRenderingFeaturesKHR {
    StructureType sType;
    void *pNext;
    Bool32 dynamicRendering;
};

struct CommandBufferInheritanceRenderingInfoKHR {
    StructureType sType;
    const void *pNext;
    RenderingFlagsKHR flags;
    uint32_t viewMask;
    uint32_t colorAttachmentCount;
    const Format *pColorAttachmentFormats;
    Format depthAttachmentFormat;
    Format stencilAttachmentFormat;
    SampleCount rasterizationSamples;
};

struct SurfaceCapabilitiesKHR {
    uint32_t minImageCount;
    uint32_t maxImageCount;
    Extent2D currentExtent;
    Extent2D minImageExtent;
    Extent2D maxImageExtent;
    uint32_t maxImageArrayLayers;
    SurfaceTransformFlagsKHR supportedTransforms;
    SurfaceTransformFlagBitsKHR currentTransform;
    CompositeAlphaFlagsKHR supportedCompositeAlpha;
    ImageUsage supportedUsage;
};

struct SurfaceFormatKHR {
    Format format;
    ColorSpaceKHR colorSpace;
};

struct SwapchainCreateInfoKHR {
    StructureType sType;
    const void *pNext;
    SwapchainCreateFlagsKHR flags;
    SurfaceKHR surface;
    uint32_t minImageCount;
    Format imageFormat;
    ColorSpaceKHR imageColorSpace;
    Extent2D imageExtent;
    uint32_t imageArrayLayers;
    ImageUsage imageUsage;
    SharingMode imageSharingMode;
    uint32_t queueFamilyIndexCount;
    const uint32_t *pQueueFamilyIndices;
    SurfaceTransformFlagBitsKHR preTransform;
    CompositeAlphaFlagBitsKHR compositeAlpha;
    PresentModeKHR presentMode;
    Bool32 clipped;
    SwapchainKHR oldSwapchain;
};

struct PresentInfoKHR {
    StructureType sType;
    const void *pNext;
    uint32_t waitSemaphoreCount;
    const Semaphore *pWaitSemaphores;
    uint32_t swapchainCount;
    const SwapchainKHR *pSwapchains;
    const uint32_t *pImageIndices;
    Result *pResults;
};

struct ImageSwapchainCreateInfoKHR {
    StructureType sType;
    const void *pNext;
    SwapchainKHR swapchain;
};

struct BindImageMemorySwapchainInfoKHR {
    StructureType sType;
    const void *pNext;
    SwapchainKHR swapchain;
    uint32_t imageIndex;
};

struct AcquireNextImageInfoKHR {
    StructureType sType;
    const void *pNext;
    SwapchainKHR swapchain;
    uint64_t timeout;
    Semaphore semaphore;
    Fence fence;
    uint32_t deviceMask;
};

struct DeviceGroupPresentCapabilitiesKHR {
    StructureType sType;
    void *pNext;
    // NOLINTNEXTLINE
    uint32_t presentMask [VK_MAX_DEVICE_GROUP_SIZE ];
    DeviceGroupPresentModeFlagsKHR modes;
};

struct DeviceGroupPresentInfoKHR {
    StructureType sType;
    const void *pNext;
    uint32_t swapchainCount;
    const uint32_t *pDeviceMasks;
    DeviceGroupPresentModeFlagBitsKHR mode;
};

struct DeviceGroupSwapchainCreateInfoKHR {
    StructureType sType;
    const void *pNext;
    DeviceGroupPresentModeFlagsKHR modes;
};

struct XcbSurfaceCreateInfoKHR {
    StructureType sType;
    const void *pNext;
    XcbSurfaceCreateFlagsKHR flags;
    xcb_connection_t *connection;
    xcb_window_t window;
};

struct PhysicalDeviceShaderAtomicFloatFeaturesEXT {
    StructureType sType;
    void *pNext;
    Bool32 shaderBufferFloat32Atomics;
    Bool32 shaderBufferFloat32AtomicAdd;
    Bool32 shaderBufferFloat64Atomics;
    Bool32 shaderBufferFloat64AtomicAdd;
    Bool32 shaderSharedFloat32Atomics;
    Bool32 shaderSharedFloat32AtomicAdd;
    Bool32 shaderSharedFloat64Atomics;
    Bool32 shaderSharedFloat64AtomicAdd;
    Bool32 shaderImageFloat32Atomics;
    Bool32 shaderImageFloat32AtomicAdd;
    Bool32 sparseImageFloat32Atomics;
    Bool32 sparseImageFloat32AtomicAdd;
};

struct PhysicalDeviceFeatures2KHR {
};

struct PhysicalDeviceProperties2KHR {
};

struct FormatProperties2KHR {
};

struct ImageFormatProperties2KHR {
};

struct PhysicalDeviceImageFormatInfo2KHR {
};

struct QueueFamilyProperties2KHR {
};

struct PhysicalDeviceMemoryProperties2KHR {
};

struct SparseImageFormatProperties2KHR {
};

struct PhysicalDeviceSparseImageFormatInfo2KHR {
};

// Command function pointers.
using PFN_vkAcquireNextImage2KHR = Result (*)(Device device, const AcquireNextImageInfoKHR *pAcquireInfo, uint32_t *pImageIndex); // NOLINT
using PFN_vkAcquireNextImageKHR = Result (*)(Device device, SwapchainKHR swapchain, uint64_t timeout, Semaphore semaphore, Fence fence, uint32_t *pImageIndex); // NOLINT
using PFN_vkAllocateCommandBuffers = Result (*)(Device device, const CommandBufferAllocateInfo *pAllocateInfo, CommandBuffer *pCommandBuffers); // NOLINT
using PFN_vkAllocateDescriptorSets = Result (*)(Device device, const DescriptorSetAllocateInfo *pAllocateInfo, DescriptorSet *pDescriptorSets); // NOLINT
using PFN_vkAllocateMemory = Result (*)(Device device, const MemoryAllocateInfo *pAllocateInfo, const AllocationCallbacks *pAllocator, DeviceMemory *pMemory); // NOLINT
using PFN_vkBeginCommandBuffer = Result (*)(CommandBuffer commandBuffer, const CommandBufferBeginInfo *pBeginInfo); // NOLINT
using PFN_vkBindBufferMemory = Result (*)(Device device, Buffer buffer, DeviceMemory memory, DeviceSize memoryOffset); // NOLINT
using PFN_vkBindBufferMemory2 = Result (*)(Device device, uint32_t bindInfoCount, const BindBufferMemoryInfo *pBindInfos); // NOLINT
using PFN_vkBindImageMemory = Result (*)(Device device, Image image, DeviceMemory memory, DeviceSize memoryOffset); // NOLINT
using PFN_vkBindImageMemory2 = Result (*)(Device device, uint32_t bindInfoCount, const BindImageMemoryInfo *pBindInfos); // NOLINT
using PFN_vkCmdBeginQuery = void (*)(CommandBuffer commandBuffer, QueryPool queryPool, uint32_t query, QueryControlFlags flags); // NOLINT
using PFN_vkCmdBeginRenderPass = void (*)(CommandBuffer commandBuffer, const RenderPassBeginInfo *pRenderPassBegin, SubpassContents contents); // NOLINT
using PFN_vkCmdBeginRenderPass2 = void (*)(CommandBuffer commandBuffer, const RenderPassBeginInfo *pRenderPassBegin, const SubpassBeginInfo *pSubpassBeginInfo); // NOLINT
using PFN_vkCmdBeginRenderingKHR = void (*)(CommandBuffer commandBuffer, const RenderingInfoKHR *pRenderingInfo); // NOLINT
using PFN_vkCmdBindDescriptorSets = void (*)(CommandBuffer commandBuffer, PipelineBindPoint pipelineBindPoint, PipelineLayout layout, uint32_t firstSet, uint32_t descriptorSetCount, const DescriptorSet *pDescriptorSets, uint32_t dynamicOffsetCount, const uint32_t *pDynamicOffsets); // NOLINT
using PFN_vkCmdBindIndexBuffer = void (*)(CommandBuffer commandBuffer, Buffer buffer, DeviceSize offset, IndexType indexType); // NOLINT
using PFN_vkCmdBindPipeline = void (*)(CommandBuffer commandBuffer, PipelineBindPoint pipelineBindPoint, Pipeline pipeline); // NOLINT
using PFN_vkCmdBindVertexBuffers = void (*)(CommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const Buffer *pBuffers, const DeviceSize *pOffsets); // NOLINT
using PFN_vkCmdBlitImage = void (*)(CommandBuffer commandBuffer, Image srcImage, ImageLayout srcImageLayout, Image dstImage, ImageLayout dstImageLayout, uint32_t regionCount, const ImageBlit *pRegions, Filter filter); // NOLINT
using PFN_vkCmdClearAttachments = void (*)(CommandBuffer commandBuffer, uint32_t attachmentCount, const ClearAttachment *pAttachments, uint32_t rectCount, const ClearRect *pRects); // NOLINT
using PFN_vkCmdClearColorImage = void (*)(CommandBuffer commandBuffer, Image image, ImageLayout imageLayout, const ClearColorValue *pColor, uint32_t rangeCount, const ImageSubresourceRange *pRanges); // NOLINT
using PFN_vkCmdClearDepthStencilImage = void (*)(CommandBuffer commandBuffer, Image image, ImageLayout imageLayout, const ClearDepthStencilValue *pDepthStencil, uint32_t rangeCount, const ImageSubresourceRange *pRanges); // NOLINT
using PFN_vkCmdCopyBuffer = void (*)(CommandBuffer commandBuffer, Buffer srcBuffer, Buffer dstBuffer, uint32_t regionCount, const BufferCopy *pRegions); // NOLINT
using PFN_vkCmdCopyBufferToImage = void (*)(CommandBuffer commandBuffer, Buffer srcBuffer, Image dstImage, ImageLayout dstImageLayout, uint32_t regionCount, const BufferImageCopy *pRegions); // NOLINT
using PFN_vkCmdCopyImage = void (*)(CommandBuffer commandBuffer, Image srcImage, ImageLayout srcImageLayout, Image dstImage, ImageLayout dstImageLayout, uint32_t regionCount, const ImageCopy *pRegions); // NOLINT
using PFN_vkCmdCopyImageToBuffer = void (*)(CommandBuffer commandBuffer, Image srcImage, ImageLayout srcImageLayout, Buffer dstBuffer, uint32_t regionCount, const BufferImageCopy *pRegions); // NOLINT
using PFN_vkCmdCopyQueryPoolResults = void (*)(CommandBuffer commandBuffer, QueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, Buffer dstBuffer, DeviceSize dstOffset, DeviceSize stride, QueryResultFlags flags); // NOLINT
using PFN_vkCmdDispatch = void (*)(CommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ); // NOLINT
using PFN_vkCmdDispatchBase = void (*)(CommandBuffer commandBuffer, uint32_t baseGroupX, uint32_t baseGroupY, uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ); // NOLINT
using PFN_vkCmdDispatchIndirect = void (*)(CommandBuffer commandBuffer, Buffer buffer, DeviceSize offset); // NOLINT
using PFN_vkCmdDraw = void (*)(CommandBuffer commandBuffer, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance); // NOLINT
using PFN_vkCmdDrawIndexed = void (*)(CommandBuffer commandBuffer, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t vertexOffset, uint32_t firstInstance); // NOLINT
using PFN_vkCmdDrawIndexedIndirect = void (*)(CommandBuffer commandBuffer, Buffer buffer, DeviceSize offset, uint32_t drawCount, uint32_t stride); // NOLINT
using PFN_vkCmdDrawIndexedIndirectCount = void (*)(CommandBuffer commandBuffer, Buffer buffer, DeviceSize offset, Buffer countBuffer, DeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride); // NOLINT
using PFN_vkCmdDrawIndirect = void (*)(CommandBuffer commandBuffer, Buffer buffer, DeviceSize offset, uint32_t drawCount, uint32_t stride); // NOLINT
using PFN_vkCmdDrawIndirectCount = void (*)(CommandBuffer commandBuffer, Buffer buffer, DeviceSize offset, Buffer countBuffer, DeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride); // NOLINT
using PFN_vkCmdEndQuery = void (*)(CommandBuffer commandBuffer, QueryPool queryPool, uint32_t query); // NOLINT
using PFN_vkCmdEndRenderPass = void (*)(CommandBuffer commandBuffer); // NOLINT
using PFN_vkCmdEndRenderPass2 = void (*)(CommandBuffer commandBuffer, const SubpassEndInfo *pSubpassEndInfo); // NOLINT
using PFN_vkCmdEndRenderingKHR = void (*)(CommandBuffer commandBuffer); // NOLINT
using PFN_vkCmdExecuteCommands = void (*)(CommandBuffer commandBuffer, uint32_t commandBufferCount, const CommandBuffer *pCommandBuffers); // NOLINT
using PFN_vkCmdFillBuffer = void (*)(CommandBuffer commandBuffer, Buffer dstBuffer, DeviceSize dstOffset, DeviceSize size, uint32_t data); // NOLINT
using PFN_vkCmdNextSubpass = void (*)(CommandBuffer commandBuffer, SubpassContents contents); // NOLINT
using PFN_vkCmdNextSubpass2 = void (*)(CommandBuffer commandBuffer, const SubpassBeginInfo *pSubpassBeginInfo, const SubpassEndInfo *pSubpassEndInfo); // NOLINT
using PFN_vkCmdPipelineBarrier = void (*)(CommandBuffer commandBuffer, PipelineStage srcStageMask, PipelineStage dstStageMask, DependencyFlags dependencyFlags, uint32_t memoryBarrierCount, const MemoryBarrier *pMemoryBarriers, uint32_t bufferMemoryBarrierCount, const BufferMemoryBarrier *pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, const ImageMemoryBarrier *pImageMemoryBarriers); // NOLINT
using PFN_vkCmdPushConstants = void (*)(CommandBuffer commandBuffer, PipelineLayout layout, ShaderStage stageFlags, uint32_t offset, uint32_t size, const void *pValues); // NOLINT
using PFN_vkCmdResetEvent = void (*)(CommandBuffer commandBuffer, Event event, PipelineStage stageMask); // NOLINT
using PFN_vkCmdResetQueryPool = void (*)(CommandBuffer commandBuffer, QueryPool queryPool, uint32_t firstQuery, uint32_t queryCount); // NOLINT
using PFN_vkCmdResolveImage = void (*)(CommandBuffer commandBuffer, Image srcImage, ImageLayout srcImageLayout, Image dstImage, ImageLayout dstImageLayout, uint32_t regionCount, const ImageResolve *pRegions); // NOLINT
using PFN_vkCmdSetBlendConstants = void (*)(CommandBuffer commandBuffer, const float blendConstants [4]); // NOLINT
using PFN_vkCmdSetDepthBias = void (*)(CommandBuffer commandBuffer, float depthBiasConstantFactor, float depthBiasClamp, float depthBiasSlopeFactor); // NOLINT
using PFN_vkCmdSetDepthBounds = void (*)(CommandBuffer commandBuffer, float minDepthBounds, float maxDepthBounds); // NOLINT
using PFN_vkCmdSetDeviceMask = void (*)(CommandBuffer commandBuffer, uint32_t deviceMask); // NOLINT
using PFN_vkCmdSetEvent = void (*)(CommandBuffer commandBuffer, Event event, PipelineStage stageMask); // NOLINT
using PFN_vkCmdSetLineWidth = void (*)(CommandBuffer commandBuffer, float lineWidth); // NOLINT
using PFN_vkCmdSetScissor = void (*)(CommandBuffer commandBuffer, uint32_t firstScissor, uint32_t scissorCount, const Rect2D *pScissors); // NOLINT
using PFN_vkCmdSetStencilCompareMask = void (*)(CommandBuffer commandBuffer, StencilFaceFlags faceMask, uint32_t compareMask); // NOLINT
using PFN_vkCmdSetStencilReference = void (*)(CommandBuffer commandBuffer, StencilFaceFlags faceMask, uint32_t reference); // NOLINT
using PFN_vkCmdSetStencilWriteMask = void (*)(CommandBuffer commandBuffer, StencilFaceFlags faceMask, uint32_t writeMask); // NOLINT
using PFN_vkCmdSetViewport = void (*)(CommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const Viewport *pViewports); // NOLINT
using PFN_vkCmdUpdateBuffer = void (*)(CommandBuffer commandBuffer, Buffer dstBuffer, DeviceSize dstOffset, DeviceSize dataSize, const void *pData); // NOLINT
using PFN_vkCmdWaitEvents = void (*)(CommandBuffer commandBuffer, uint32_t eventCount, const Event *pEvents, PipelineStage srcStageMask, PipelineStage dstStageMask, uint32_t memoryBarrierCount, const MemoryBarrier *pMemoryBarriers, uint32_t bufferMemoryBarrierCount, const BufferMemoryBarrier *pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, const ImageMemoryBarrier *pImageMemoryBarriers); // NOLINT
using PFN_vkCmdWriteTimestamp = void (*)(CommandBuffer commandBuffer, PipelineStage pipelineStage, QueryPool queryPool, uint32_t query); // NOLINT
using PFN_vkCreateBuffer = Result (*)(Device device, const BufferCreateInfo *pCreateInfo, const AllocationCallbacks *pAllocator, Buffer *pBuffer); // NOLINT
using PFN_vkCreateBufferView = Result (*)(Device device, const BufferViewCreateInfo *pCreateInfo, const AllocationCallbacks *pAllocator, BufferView *pView); // NOLINT
using PFN_vkCreateCommandPool = Result (*)(Device device, const CommandPoolCreateInfo *pCreateInfo, const AllocationCallbacks *pAllocator, CommandPool *pCommandPool); // NOLINT
using PFN_vkCreateComputePipelines = Result (*)(Device device, PipelineCache pipelineCache, uint32_t createInfoCount, const ComputePipelineCreateInfo *pCreateInfos, const AllocationCallbacks *pAllocator, Pipeline *pPipelines); // NOLINT
using PFN_vkCreateDescriptorPool = Result (*)(Device device, const DescriptorPoolCreateInfo *pCreateInfo, const AllocationCallbacks *pAllocator, DescriptorPool *pDescriptorPool); // NOLINT
using PFN_vkCreateDescriptorSetLayout = Result (*)(Device device, const DescriptorSetLayoutCreateInfo *pCreateInfo, const AllocationCallbacks *pAllocator, DescriptorSetLayout *pSetLayout); // NOLINT
using PFN_vkCreateDescriptorUpdateTemplate = Result (*)(Device device, const DescriptorUpdateTemplateCreateInfo *pCreateInfo, const AllocationCallbacks *pAllocator, DescriptorUpdateTemplate *pDescriptorUpdateTemplate); // NOLINT
using PFN_vkCreateDevice = Result (*)(PhysicalDevice physicalDevice, const DeviceCreateInfo *pCreateInfo, const AllocationCallbacks *pAllocator, Device *pDevice); // NOLINT
using PFN_vkCreateEvent = Result (*)(Device device, const EventCreateInfo *pCreateInfo, const AllocationCallbacks *pAllocator, Event *pEvent); // NOLINT
using PFN_vkCreateFence = Result (*)(Device device, const FenceCreateInfo *pCreateInfo, const AllocationCallbacks *pAllocator, Fence *pFence); // NOLINT
using PFN_vkCreateFramebuffer = Result (*)(Device device, const FramebufferCreateInfo *pCreateInfo, const AllocationCallbacks *pAllocator, Framebuffer *pFramebuffer); // NOLINT
using PFN_vkCreateGraphicsPipelines = Result (*)(Device device, PipelineCache pipelineCache, uint32_t createInfoCount, const GraphicsPipelineCreateInfo *pCreateInfos, const AllocationCallbacks *pAllocator, Pipeline *pPipelines); // NOLINT
using PFN_vkCreateImage = Result (*)(Device device, const ImageCreateInfo *pCreateInfo, const AllocationCallbacks *pAllocator, Image *pImage); // NOLINT
using PFN_vkCreateImageView = Result (*)(Device device, const ImageViewCreateInfo *pCreateInfo, const AllocationCallbacks *pAllocator, ImageView *pView); // NOLINT
using PFN_vkCreateInstance = Result (*)(const InstanceCreateInfo *pCreateInfo, const AllocationCallbacks *pAllocator, Instance *pInstance); // NOLINT
using PFN_vkCreatePipelineCache = Result (*)(Device device, const PipelineCacheCreateInfo *pCreateInfo, const AllocationCallbacks *pAllocator, PipelineCache *pPipelineCache); // NOLINT
using PFN_vkCreatePipelineLayout = Result (*)(Device device, const PipelineLayoutCreateInfo *pCreateInfo, const AllocationCallbacks *pAllocator, PipelineLayout *pPipelineLayout); // NOLINT
using PFN_vkCreateQueryPool = Result (*)(Device device, const QueryPoolCreateInfo *pCreateInfo, const AllocationCallbacks *pAllocator, QueryPool *pQueryPool); // NOLINT
using PFN_vkCreateRenderPass = Result (*)(Device device, const RenderPassCreateInfo *pCreateInfo, const AllocationCallbacks *pAllocator, RenderPass *pRenderPass); // NOLINT
using PFN_vkCreateRenderPass2 = Result (*)(Device device, const RenderPassCreateInfo2 *pCreateInfo, const AllocationCallbacks *pAllocator, RenderPass *pRenderPass); // NOLINT
using PFN_vkCreateSampler = Result (*)(Device device, const SamplerCreateInfo *pCreateInfo, const AllocationCallbacks *pAllocator, Sampler *pSampler); // NOLINT
using PFN_vkCreateSamplerYcbcrConversion = Result (*)(Device device, const SamplerYcbcrConversionCreateInfo *pCreateInfo, const AllocationCallbacks *pAllocator, SamplerYcbcrConversion *pYcbcrConversion); // NOLINT
using PFN_vkCreateSemaphore = Result (*)(Device device, const SemaphoreCreateInfo *pCreateInfo, const AllocationCallbacks *pAllocator, Semaphore *pSemaphore); // NOLINT
using PFN_vkCreateShaderModule = Result (*)(Device device, const ShaderModuleCreateInfo *pCreateInfo, const AllocationCallbacks *pAllocator, ShaderModule *pShaderModule); // NOLINT
using PFN_vkCreateSwapchainKHR = Result (*)(Device device, const SwapchainCreateInfoKHR *pCreateInfo, const AllocationCallbacks *pAllocator, SwapchainKHR *pSwapchain); // NOLINT
using PFN_vkCreateXcbSurfaceKHR = Result (*)(Instance instance, const XcbSurfaceCreateInfoKHR *pCreateInfo, const AllocationCallbacks *pAllocator, SurfaceKHR *pSurface); // NOLINT
using PFN_vkDestroyBuffer = void (*)(Device device, Buffer buffer, const AllocationCallbacks *pAllocator); // NOLINT
using PFN_vkDestroyBufferView = void (*)(Device device, BufferView bufferView, const AllocationCallbacks *pAllocator); // NOLINT
using PFN_vkDestroyCommandPool = void (*)(Device device, CommandPool commandPool, const AllocationCallbacks *pAllocator); // NOLINT
using PFN_vkDestroyDescriptorPool = void (*)(Device device, DescriptorPool descriptorPool, const AllocationCallbacks *pAllocator); // NOLINT
using PFN_vkDestroyDescriptorSetLayout = void (*)(Device device, DescriptorSetLayout descriptorSetLayout, const AllocationCallbacks *pAllocator); // NOLINT
using PFN_vkDestroyDescriptorUpdateTemplate = void (*)(Device device, DescriptorUpdateTemplate descriptorUpdateTemplate, const AllocationCallbacks *pAllocator); // NOLINT
using PFN_vkDestroyDevice = void (*)(Device device, const AllocationCallbacks *pAllocator); // NOLINT
using PFN_vkDestroyEvent = void (*)(Device device, Event event, const AllocationCallbacks *pAllocator); // NOLINT
using PFN_vkDestroyFence = void (*)(Device device, Fence fence, const AllocationCallbacks *pAllocator); // NOLINT
using PFN_vkDestroyFramebuffer = void (*)(Device device, Framebuffer framebuffer, const AllocationCallbacks *pAllocator); // NOLINT
using PFN_vkDestroyImage = void (*)(Device device, Image image, const AllocationCallbacks *pAllocator); // NOLINT
using PFN_vkDestroyImageView = void (*)(Device device, ImageView imageView, const AllocationCallbacks *pAllocator); // NOLINT
using PFN_vkDestroyInstance = void (*)(Instance instance, const AllocationCallbacks *pAllocator); // NOLINT
using PFN_vkDestroyPipeline = void (*)(Device device, Pipeline pipeline, const AllocationCallbacks *pAllocator); // NOLINT
using PFN_vkDestroyPipelineCache = void (*)(Device device, PipelineCache pipelineCache, const AllocationCallbacks *pAllocator); // NOLINT
using PFN_vkDestroyPipelineLayout = void (*)(Device device, PipelineLayout pipelineLayout, const AllocationCallbacks *pAllocator); // NOLINT
using PFN_vkDestroyQueryPool = void (*)(Device device, QueryPool queryPool, const AllocationCallbacks *pAllocator); // NOLINT
using PFN_vkDestroyRenderPass = void (*)(Device device, RenderPass renderPass, const AllocationCallbacks *pAllocator); // NOLINT
using PFN_vkDestroySampler = void (*)(Device device, Sampler sampler, const AllocationCallbacks *pAllocator); // NOLINT
using PFN_vkDestroySamplerYcbcrConversion = void (*)(Device device, SamplerYcbcrConversion ycbcrConversion, const AllocationCallbacks *pAllocator); // NOLINT
using PFN_vkDestroySemaphore = void (*)(Device device, Semaphore semaphore, const AllocationCallbacks *pAllocator); // NOLINT
using PFN_vkDestroyShaderModule = void (*)(Device device, ShaderModule shaderModule, const AllocationCallbacks *pAllocator); // NOLINT
using PFN_vkDestroySurfaceKHR = void (*)(Instance instance, SurfaceKHR surface, const AllocationCallbacks *pAllocator); // NOLINT
using PFN_vkDestroySwapchainKHR = void (*)(Device device, SwapchainKHR swapchain, const AllocationCallbacks *pAllocator); // NOLINT
using PFN_vkDeviceWaitIdle = Result (*)(Device device); // NOLINT
using PFN_vkEndCommandBuffer = Result (*)(CommandBuffer commandBuffer); // NOLINT
using PFN_vkEnumerateDeviceExtensionProperties = Result (*)(PhysicalDevice physicalDevice, const char *pLayerName, uint32_t *pPropertyCount, ExtensionProperties *pProperties); // NOLINT
using PFN_vkEnumerateDeviceLayerProperties = Result (*)(PhysicalDevice physicalDevice, uint32_t *pPropertyCount, LayerProperties *pProperties); // NOLINT
using PFN_vkEnumerateInstanceExtensionProperties = Result (*)(const char *pLayerName, uint32_t *pPropertyCount, ExtensionProperties *pProperties); // NOLINT
using PFN_vkEnumerateInstanceLayerProperties = Result (*)(uint32_t *pPropertyCount, LayerProperties *pProperties); // NOLINT
using PFN_vkEnumerateInstanceVersion = Result (*)(uint32_t *pApiVersion); // NOLINT
using PFN_vkEnumeratePhysicalDeviceGroups = Result (*)(Instance instance, uint32_t *pPhysicalDeviceGroupCount, PhysicalDeviceGroupProperties *pPhysicalDeviceGroupProperties); // NOLINT
using PFN_vkEnumeratePhysicalDevices = Result (*)(Instance instance, uint32_t *pPhysicalDeviceCount, PhysicalDevice *pPhysicalDevices); // NOLINT
using PFN_vkFlushMappedMemoryRanges = Result (*)(Device device, uint32_t memoryRangeCount, const MappedMemoryRange *pMemoryRanges); // NOLINT
using PFN_vkFreeCommandBuffers = void (*)(Device device, CommandPool commandPool, uint32_t commandBufferCount, const CommandBuffer *pCommandBuffers); // NOLINT
using PFN_vkFreeDescriptorSets = Result (*)(Device device, DescriptorPool descriptorPool, uint32_t descriptorSetCount, const DescriptorSet *pDescriptorSets); // NOLINT
using PFN_vkFreeMemory = void (*)(Device device, DeviceMemory memory, const AllocationCallbacks *pAllocator); // NOLINT
using PFN_vkGetBufferDeviceAddress = DeviceAddress (*)(Device device, const BufferDeviceAddressInfo *pInfo); // NOLINT
using PFN_vkGetBufferMemoryRequirements = void (*)(Device device, Buffer buffer, MemoryRequirements *pMemoryRequirements); // NOLINT
using PFN_vkGetBufferMemoryRequirements2 = void (*)(Device device, const BufferMemoryRequirementsInfo2 *pInfo, MemoryRequirements2 *pMemoryRequirements); // NOLINT
using PFN_vkGetBufferOpaqueCaptureAddress = uint64_t (*)(Device device, const BufferDeviceAddressInfo *pInfo); // NOLINT
using PFN_vkGetDescriptorSetLayoutSupport = void (*)(Device device, const DescriptorSetLayoutCreateInfo *pCreateInfo, DescriptorSetLayoutSupport *pSupport); // NOLINT
using PFN_vkGetDeviceGroupPeerMemoryFeatures = void (*)(Device device, uint32_t heapIndex, uint32_t localDeviceIndex, uint32_t remoteDeviceIndex, PeerMemoryFeature *pPeerMemoryFeatures); // NOLINT
using PFN_vkGetDeviceGroupPresentCapabilitiesKHR = Result (*)(Device device, DeviceGroupPresentCapabilitiesKHR *pDeviceGroupPresentCapabilities); // NOLINT
using PFN_vkGetDeviceGroupSurfacePresentModesKHR = Result (*)(Device device, SurfaceKHR surface, DeviceGroupPresentModeFlagsKHR *pModes); // NOLINT
using PFN_vkGetDeviceMemoryCommitment = void (*)(Device device, DeviceMemory memory, DeviceSize *pCommittedMemoryInBytes); // NOLINT
using PFN_vkGetDeviceMemoryOpaqueCaptureAddress = uint64_t (*)(Device device, const DeviceMemoryOpaqueCaptureAddressInfo *pInfo); // NOLINT
using PFN_vkGetDeviceProcAddr = PFN_vkVoidFunction (*)(Device device, const char *pName); // NOLINT
using PFN_vkGetDeviceQueue = void (*)(Device device, uint32_t queueFamilyIndex, uint32_t queueIndex, Queue *pQueue); // NOLINT
using PFN_vkGetDeviceQueue2 = void (*)(Device device, const DeviceQueueInfo2 *pQueueInfo, Queue *pQueue); // NOLINT
using PFN_vkGetEventStatus = Result (*)(Device device, Event event); // NOLINT
using PFN_vkGetFenceStatus = Result (*)(Device device, Fence fence); // NOLINT
using PFN_vkGetImageMemoryRequirements = void (*)(Device device, Image image, MemoryRequirements *pMemoryRequirements); // NOLINT
using PFN_vkGetImageMemoryRequirements2 = void (*)(Device device, const ImageMemoryRequirementsInfo2 *pInfo, MemoryRequirements2 *pMemoryRequirements); // NOLINT
using PFN_vkGetImageSparseMemoryRequirements = void (*)(Device device, Image image, uint32_t *pSparseMemoryRequirementCount, SparseImageMemoryRequirements *pSparseMemoryRequirements); // NOLINT
using PFN_vkGetImageSparseMemoryRequirements2 = void (*)(Device device, const ImageSparseMemoryRequirementsInfo2 *pInfo, uint32_t *pSparseMemoryRequirementCount, SparseImageMemoryRequirements2 *pSparseMemoryRequirements); // NOLINT
using PFN_vkGetImageSubresourceLayout = void (*)(Device device, Image image, const ImageSubresource *pSubresource, SubresourceLayout *pLayout); // NOLINT
using PFN_vkGetInstanceProcAddr = PFN_vkVoidFunction (*)(Instance instance, const char *pName); // NOLINT
using PFN_vkGetPhysicalDeviceExternalBufferProperties = void (*)(PhysicalDevice physicalDevice, const PhysicalDeviceExternalBufferInfo *pExternalBufferInfo, ExternalBufferProperties *pExternalBufferProperties); // NOLINT
using PFN_vkGetPhysicalDeviceExternalFenceProperties = void (*)(PhysicalDevice physicalDevice, const PhysicalDeviceExternalFenceInfo *pExternalFenceInfo, ExternalFenceProperties *pExternalFenceProperties); // NOLINT
using PFN_vkGetPhysicalDeviceExternalSemaphoreProperties = void (*)(PhysicalDevice physicalDevice, const PhysicalDeviceExternalSemaphoreInfo *pExternalSemaphoreInfo, ExternalSemaphoreProperties *pExternalSemaphoreProperties); // NOLINT
using PFN_vkGetPhysicalDeviceFeatures = void (*)(PhysicalDevice physicalDevice, PhysicalDeviceFeatures *pFeatures); // NOLINT
using PFN_vkGetPhysicalDeviceFeatures2 = void (*)(PhysicalDevice physicalDevice, PhysicalDeviceFeatures2 *pFeatures); // NOLINT
using PFN_vkGetPhysicalDeviceFormatProperties = void (*)(PhysicalDevice physicalDevice, Format format, FormatProperties *pFormatProperties); // NOLINT
using PFN_vkGetPhysicalDeviceFormatProperties2 = void (*)(PhysicalDevice physicalDevice, Format format, FormatProperties2 *pFormatProperties); // NOLINT
using PFN_vkGetPhysicalDeviceImageFormatProperties = Result (*)(PhysicalDevice physicalDevice, Format format, ImageType type, ImageTiling tiling, ImageUsage usage, ImageCreateFlags flags, ImageFormatProperties *pImageFormatProperties); // NOLINT
using PFN_vkGetPhysicalDeviceImageFormatProperties2 = Result (*)(PhysicalDevice physicalDevice, const PhysicalDeviceImageFormatInfo2 *pImageFormatInfo, ImageFormatProperties2 *pImageFormatProperties); // NOLINT
using PFN_vkGetPhysicalDeviceMemoryProperties = void (*)(PhysicalDevice physicalDevice, PhysicalDeviceMemoryProperties *pMemoryProperties); // NOLINT
using PFN_vkGetPhysicalDeviceMemoryProperties2 = void (*)(PhysicalDevice physicalDevice, PhysicalDeviceMemoryProperties2 *pMemoryProperties); // NOLINT
using PFN_vkGetPhysicalDevicePresentRectanglesKHR = Result (*)(PhysicalDevice physicalDevice, SurfaceKHR surface, uint32_t *pRectCount, Rect2D *pRects); // NOLINT
using PFN_vkGetPhysicalDeviceProperties = void (*)(PhysicalDevice physicalDevice, PhysicalDeviceProperties *pProperties); // NOLINT
using PFN_vkGetPhysicalDeviceProperties2 = void (*)(PhysicalDevice physicalDevice, PhysicalDeviceProperties2 *pProperties); // NOLINT
using PFN_vkGetPhysicalDeviceQueueFamilyProperties = void (*)(PhysicalDevice physicalDevice, uint32_t *pQueueFamilyPropertyCount, QueueFamilyProperties *pQueueFamilyProperties); // NOLINT
using PFN_vkGetPhysicalDeviceQueueFamilyProperties2 = void (*)(PhysicalDevice physicalDevice, uint32_t *pQueueFamilyPropertyCount, QueueFamilyProperties2 *pQueueFamilyProperties); // NOLINT
using PFN_vkGetPhysicalDeviceSparseImageFormatProperties = void (*)(PhysicalDevice physicalDevice, Format format, ImageType type, SampleCount samples, ImageUsage usage, ImageTiling tiling, uint32_t *pPropertyCount, SparseImageFormatProperties *pProperties); // NOLINT
using PFN_vkGetPhysicalDeviceSparseImageFormatProperties2 = void (*)(PhysicalDevice physicalDevice, const PhysicalDeviceSparseImageFormatInfo2 *pFormatInfo, uint32_t *pPropertyCount, SparseImageFormatProperties2 *pProperties); // NOLINT
using PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR = Result (*)(PhysicalDevice physicalDevice, SurfaceKHR surface, SurfaceCapabilitiesKHR *pSurfaceCapabilities); // NOLINT
using PFN_vkGetPhysicalDeviceSurfaceFormatsKHR = Result (*)(PhysicalDevice physicalDevice, SurfaceKHR surface, uint32_t *pSurfaceFormatCount, SurfaceFormatKHR *pSurfaceFormats); // NOLINT
using PFN_vkGetPhysicalDeviceSurfacePresentModesKHR = Result (*)(PhysicalDevice physicalDevice, SurfaceKHR surface, uint32_t *pPresentModeCount, PresentModeKHR *pPresentModes); // NOLINT
using PFN_vkGetPhysicalDeviceSurfaceSupportKHR = Result (*)(PhysicalDevice physicalDevice, uint32_t queueFamilyIndex, SurfaceKHR surface, Bool32 *pSupported); // NOLINT
using PFN_vkGetPhysicalDeviceXcbPresentationSupportKHR = Bool32 (*)(PhysicalDevice physicalDevice, uint32_t queueFamilyIndex, xcb_connection_t *connection, xcb_visualid_t visual_id); // NOLINT
using PFN_vkGetPipelineCacheData = Result (*)(Device device, PipelineCache pipelineCache, size_t *pDataSize, void *pData); // NOLINT
using PFN_vkGetQueryPoolResults = Result (*)(Device device, QueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, size_t dataSize, void *pData, DeviceSize stride, QueryResultFlags flags); // NOLINT
using PFN_vkGetRenderAreaGranularity = void (*)(Device device, RenderPass renderPass, Extent2D *pGranularity); // NOLINT
using PFN_vkGetSemaphoreCounterValue = Result (*)(Device device, Semaphore semaphore, uint64_t *pValue); // NOLINT
using PFN_vkGetSwapchainImagesKHR = Result (*)(Device device, SwapchainKHR swapchain, uint32_t *pSwapchainImageCount, Image *pSwapchainImages); // NOLINT
using PFN_vkInvalidateMappedMemoryRanges = Result (*)(Device device, uint32_t memoryRangeCount, const MappedMemoryRange *pMemoryRanges); // NOLINT
using PFN_vkMapMemory = Result (*)(Device device, DeviceMemory memory, DeviceSize offset, DeviceSize size, MemoryMapFlags flags, void ** ppData); // NOLINT
using PFN_vkMergePipelineCaches = Result (*)(Device device, PipelineCache dstCache, uint32_t srcCacheCount, const PipelineCache *pSrcCaches); // NOLINT
using PFN_vkQueueBindSparse = Result (*)(Queue queue, uint32_t bindInfoCount, const BindSparseInfo *pBindInfo, Fence fence); // NOLINT
using PFN_vkQueuePresentKHR = Result (*)(Queue queue, const PresentInfoKHR *pPresentInfo); // NOLINT
using PFN_vkQueueSubmit = Result (*)(Queue queue, uint32_t submitCount, const SubmitInfo *pSubmits, Fence fence); // NOLINT
using PFN_vkQueueWaitIdle = Result (*)(Queue queue); // NOLINT
using PFN_vkResetCommandBuffer = Result (*)(CommandBuffer commandBuffer, CommandBufferResetFlags flags); // NOLINT
using PFN_vkResetCommandPool = Result (*)(Device device, CommandPool commandPool, CommandPoolResetFlags flags); // NOLINT
using PFN_vkResetDescriptorPool = Result (*)(Device device, DescriptorPool descriptorPool, DescriptorPoolResetFlags flags); // NOLINT
using PFN_vkResetEvent = Result (*)(Device device, Event event); // NOLINT
using PFN_vkResetFences = Result (*)(Device device, uint32_t fenceCount, const Fence *pFences); // NOLINT
using PFN_vkResetQueryPool = void (*)(Device device, QueryPool queryPool, uint32_t firstQuery, uint32_t queryCount); // NOLINT
using PFN_vkSetEvent = Result (*)(Device device, Event event); // NOLINT
using PFN_vkSignalSemaphore = Result (*)(Device device, const SemaphoreSignalInfo *pSignalInfo); // NOLINT
using PFN_vkTrimCommandPool = void (*)(Device device, CommandPool commandPool, CommandPoolTrimFlags flags); // NOLINT
using PFN_vkUnmapMemory = void (*)(Device device, DeviceMemory memory); // NOLINT
using PFN_vkUpdateDescriptorSetWithTemplate = void (*)(Device device, DescriptorSet descriptorSet, DescriptorUpdateTemplate descriptorUpdateTemplate, const void *pData); // NOLINT
using PFN_vkUpdateDescriptorSets = void (*)(Device device, uint32_t descriptorWriteCount, const WriteDescriptorSet *pDescriptorWrites, uint32_t descriptorCopyCount, const CopyDescriptorSet *pDescriptorCopies); // NOLINT
using PFN_vkWaitForFences = Result (*)(Device device, uint32_t fenceCount, const Fence *pFences, Bool32 waitAll, uint64_t timeout); // NOLINT
using PFN_vkWaitSemaphores = Result (*)(Device device, const SemaphoreWaitInfo *pWaitInfo, uint64_t timeout); // NOLINT

} // namespace vull::vk
